matlab/src/bits/data.hpp:257:47: style:inconclusive: Boolean expression 'a.getDeviceType()==b.getDeviceType()' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
    ((a.getDeviceType() == b.getDeviceType()) & (a.getDataType() == b.getDataType())) ;
                                              ^
matlab/src/bits/data.cu:203:31: style:inconclusive: Boolean expression 'deviceType==deviceType_' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  (deviceType == deviceType_) &
                              ^
matlab/src/bits/data.cu:204:27: style:inconclusive: Boolean expression 'size>=size_' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  (dataType == dataType_) &
                          ^
matlab/src/bits/data.cu:486:18: warning: Member variable 'TensorShape::dimensions' is not initialized in the constructor. [uninitMemberVar]
vl::TensorShape::TensorShape()
                 ^
matlab/src/bits/data.hpp:241:16: style:inconclusive: Member variable 'Tensor::deviceType' is in the wrong place in the initializer list. [initializerList]
    DeviceType deviceType ;
               ^
matlab/src/bits/data.cu:614:3: note: Member variable 'Tensor::deviceType' is in the wrong place in the initializer list.
  deviceType(VLDT_CPU), memory(NULL), memorySize(0)
  ^
matlab/src/bits/data.hpp:241:16: note: Member variable 'Tensor::deviceType' is in the wrong place in the initializer list.
    DeviceType deviceType ;
               ^
matlab/src/bits/data.hpp:241:16: style:inconclusive: Member variable 'Tensor::deviceType' is in the wrong place in the initializer list. [initializerList]
    DeviceType deviceType ;
               ^
matlab/src/bits/data.hpp:248:43: note: Member variable 'Tensor::deviceType' is in the wrong place in the initializer list.
  : TensorShape(t), dataType(t.dataType), deviceType(t.deviceType),
                                          ^
matlab/src/bits/data.hpp:241:16: note: Member variable 'Tensor::deviceType' is in the wrong place in the initializer list.
    DeviceType deviceType ;
               ^
matlab/src/bits/data.hpp:241:16: style:inconclusive: Member variable 'Tensor::deviceType' is in the wrong place in the initializer list. [initializerList]
    DeviceType deviceType ;
               ^
matlab/src/bits/data.cu:621:1: note: Member variable 'Tensor::deviceType' is in the wrong place in the initializer list.
deviceType(deviceType),
^
matlab/src/bits/data.hpp:241:16: note: Member variable 'Tensor::deviceType' is in the wrong place in the initializer list.
    DeviceType deviceType ;
               ^
matlab/src/bits/data.hpp:196:10: performance:inconclusive: Technically the member function 'vl::TensorShape::reshape' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void reshape(TensorShape const & shape) ; // same as operator=
         ^
matlab/src/bits/data.cu:603:23: note: Technically the member function 'vl::TensorShape::reshape' can be static (but you may consider moving to unnamed namespace).
void vl::TensorShape::reshape(TensorShape const & newShape)
                      ^
matlab/src/bits/data.hpp:196:10: note: Technically the member function 'vl::TensorShape::reshape' can be static (but you may consider moving to unnamed namespace).
    void reshape(TensorShape const & shape) ; // same as operator=
         ^
matlab/src/bits/data.cu:158:10: performance:inconclusive: Technically the member function 'vl::impl::Randn::f' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  double f(double x) {
         ^
matlab/src/bits/data.cu:163:10: performance:inconclusive: Technically the member function 'vl::impl::Randn::invf' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  double invf(double y) {
         ^
matlab/src/bits/data.cu:200:35: style:inconclusive: Function 'init' argument 1 names different: declaration 'deviceType' definition 'deviceType_'. [funcArgNamesDifferent]
vl::impl::Buffer::init(DeviceType deviceType_, DataType dataType_, size_t size_)
                                  ^
matlab/src/bits/data.hpp:125:37: note: Function 'init' argument 1 names different: declaration 'deviceType' definition 'deviceType_'.
      vl::ErrorCode init(DeviceType deviceType, DataType dataType, size_t size) ;
                                    ^
matlab/src/bits/data.cu:200:35: note: Function 'init' argument 1 names different: declaration 'deviceType' definition 'deviceType_'.
vl::impl::Buffer::init(DeviceType deviceType_, DataType dataType_, size_t size_)
                                  ^
matlab/src/bits/data.cu:200:57: style:inconclusive: Function 'init' argument 2 names different: declaration 'dataType' definition 'dataType_'. [funcArgNamesDifferent]
vl::impl::Buffer::init(DeviceType deviceType_, DataType dataType_, size_t size_)
                                                        ^
matlab/src/bits/data.hpp:125:58: note: Function 'init' argument 2 names different: declaration 'dataType' definition 'dataType_'.
      vl::ErrorCode init(DeviceType deviceType, DataType dataType, size_t size) ;
                                                         ^
matlab/src/bits/data.cu:200:57: note: Function 'init' argument 2 names different: declaration 'dataType' definition 'dataType_'.
vl::impl::Buffer::init(DeviceType deviceType_, DataType dataType_, size_t size_)
                                                        ^
matlab/src/bits/data.cu:200:75: style:inconclusive: Function 'init' argument 3 names different: declaration 'size' definition 'size_'. [funcArgNamesDifferent]
vl::impl::Buffer::init(DeviceType deviceType_, DataType dataType_, size_t size_)
                                                                          ^
matlab/src/bits/data.hpp:125:75: note: Function 'init' argument 3 names different: declaration 'size' definition 'size_'.
      vl::ErrorCode init(DeviceType deviceType, DataType dataType, size_t size) ;
                                                                          ^
matlab/src/bits/data.cu:200:75: note: Function 'init' argument 3 names different: declaration 'size' definition 'size_'.
vl::impl::Buffer::init(DeviceType deviceType_, DataType dataType_, size_t size_)
                                                                          ^
matlab/src/bits/data.cu:333:57: style:inconclusive: Function 'passError' argument 2 names different: declaration 'message' definition 'description'. [funcArgNamesDifferent]
vl::Context::passError(vl::ErrorCode error, char const* description)
                                                        ^
matlab/src/bits/data.hpp:158:63: note: Function 'passError' argument 2 names different: declaration 'message' definition 'description'.
    vl::ErrorCode passError(vl::ErrorCode error, char const * message = NULL) ;
                                                              ^
matlab/src/bits/data.cu:333:57: note: Function 'passError' argument 2 names different: declaration 'message' definition 'description'.
vl::Context::passError(vl::ErrorCode error, char const* description)
                                                        ^
matlab/src/bits/data.cu:344:56: style:inconclusive: Function 'setError' argument 2 names different: declaration 'message' definition 'description'. [funcArgNamesDifferent]
vl::Context::setError(vl::ErrorCode error, char const* description)
                                                       ^
matlab/src/bits/data.hpp:159:62: note: Function 'setError' argument 2 names different: declaration 'message' definition 'description'.
    vl::ErrorCode setError(vl::ErrorCode error, char const * message = NULL) ;
                                                             ^
matlab/src/bits/data.cu:344:56: note: Function 'setError' argument 2 names different: declaration 'message' definition 'description'.
vl::Context::setError(vl::ErrorCode error, char const* description)
                                                       ^
matlab/src/bits/data.cu:396:38: style:inconclusive: Function 'getWorkspace' argument 1 names different: declaration 'device' definition 'deviceType'. [funcArgNamesDifferent]
vl::Context::getWorkspace(DeviceType deviceType, size_t size)
                                     ^
matlab/src/bits/data.hpp:149:36: note: Function 'getWorkspace' argument 1 names different: declaration 'device' definition 'deviceType'.
    void * getWorkspace(DeviceType device, size_t size) ;
                                   ^
matlab/src/bits/data.cu:396:38: note: Function 'getWorkspace' argument 1 names different: declaration 'device' definition 'deviceType'.
vl::Context::getWorkspace(DeviceType deviceType, size_t size)
                                     ^
matlab/src/bits/data.cu:407:40: style:inconclusive: Function 'clearWorkspace' argument 1 names different: declaration 'device' definition 'deviceType'. [funcArgNamesDifferent]
vl::Context::clearWorkspace(DeviceType deviceType)
                                       ^
matlab/src/bits/data.hpp:150:36: note: Function 'clearWorkspace' argument 1 names different: declaration 'device' definition 'deviceType'.
    void clearWorkspace(DeviceType device) ;
                                   ^
matlab/src/bits/data.cu:407:40: note: Function 'clearWorkspace' argument 1 names different: declaration 'device' definition 'deviceType'.
vl::Context::clearWorkspace(DeviceType deviceType)
                                       ^
matlab/src/bits/data.cu:426:36: style:inconclusive: Function 'getAllOnes' argument 1 names different: declaration 'device' definition 'deviceType'. [funcArgNamesDifferent]
vl::Context::getAllOnes(DeviceType deviceType, DataType dataType, size_t size)
                                   ^
matlab/src/bits/data.hpp:151:34: note: Function 'getAllOnes' argument 1 names different: declaration 'device' definition 'deviceType'.
    void * getAllOnes(DeviceType device, DataType type, size_t size) ;
                                 ^
matlab/src/bits/data.cu:426:36: note: Function 'getAllOnes' argument 1 names different: declaration 'device' definition 'deviceType'.
vl::Context::getAllOnes(DeviceType deviceType, DataType dataType, size_t size)
                                   ^
matlab/src/bits/data.cu:426:57: style:inconclusive: Function 'getAllOnes' argument 2 names different: declaration 'type' definition 'dataType'. [funcArgNamesDifferent]
vl::Context::getAllOnes(DeviceType deviceType, DataType dataType, size_t size)
                                                        ^
matlab/src/bits/data.hpp:151:51: note: Function 'getAllOnes' argument 2 names different: declaration 'type' definition 'dataType'.
    void * getAllOnes(DeviceType device, DataType type, size_t size) ;
                                                  ^
matlab/src/bits/data.cu:426:57: note: Function 'getAllOnes' argument 2 names different: declaration 'type' definition 'dataType'.
vl::Context::getAllOnes(DeviceType deviceType, DataType dataType, size_t size)
                                                        ^
matlab/src/bits/data.cu:477:38: style:inconclusive: Function 'clearAllOnes' argument 1 names different: declaration 'device' definition 'deviceType'. [funcArgNamesDifferent]
vl::Context::clearAllOnes(DeviceType deviceType)
                                     ^
matlab/src/bits/data.hpp:152:34: note: Function 'clearAllOnes' argument 1 names different: declaration 'device' definition 'deviceType'.
    void clearAllOnes(DeviceType device) ;
                                 ^
matlab/src/bits/data.cu:477:38: note: Function 'clearAllOnes' argument 1 names different: declaration 'device' definition 'deviceType'.
vl::Context::clearAllOnes(DeviceType deviceType)
                                     ^
matlab/src/bits/data.cu:512:52: style:inconclusive: Function 'setDimensions' argument 1 names different: declaration 'dimensions' definition 'newDimensions'. [funcArgNamesDifferent]
void vl::TensorShape::setDimensions(size_t const * newDimensions, size_t newNumDimensions)
                                                   ^
matlab/src/bits/data.hpp:190:39: note: Function 'setDimensions' argument 1 names different: declaration 'dimensions' definition 'newDimensions'.
    void setDimensions(size_t const * dimensions, size_t numDimensions) ;
                                      ^
matlab/src/bits/data.cu:512:52: note: Function 'setDimensions' argument 1 names different: declaration 'dimensions' definition 'newDimensions'.
void vl::TensorShape::setDimensions(size_t const * newDimensions, size_t newNumDimensions)
                                                   ^
matlab/src/bits/data.cu:512:74: style:inconclusive: Function 'setDimensions' argument 2 names different: declaration 'numDimensions' definition 'newNumDimensions'. [funcArgNamesDifferent]
void vl::TensorShape::setDimensions(size_t const * newDimensions, size_t newNumDimensions)
                                                                         ^
matlab/src/bits/data.hpp:190:58: note: Function 'setDimensions' argument 2 names different: declaration 'numDimensions' definition 'newNumDimensions'.
    void setDimensions(size_t const * dimensions, size_t numDimensions) ;
                                                         ^
matlab/src/bits/data.cu:512:74: note: Function 'setDimensions' argument 2 names different: declaration 'numDimensions' definition 'newNumDimensions'.
void vl::TensorShape::setDimensions(size_t const * newDimensions, size_t newNumDimensions)
                                                                         ^
matlab/src/bits/data.cu:585:38: style:inconclusive: Function 'reshape' argument 1 names different: declaration 'numDimensions' definition 'newNumDimensions'. [funcArgNamesDifferent]
void vl::TensorShape::reshape(size_t newNumDimensions)
                                     ^
matlab/src/bits/data.hpp:195:25: note: Function 'reshape' argument 1 names different: declaration 'numDimensions' definition 'newNumDimensions'.
    void reshape(size_t numDimensions) ; // squash or stretch to numDimensions
                        ^
matlab/src/bits/data.cu:585:38: note: Function 'reshape' argument 1 names different: declaration 'numDimensions' definition 'newNumDimensions'.
void vl::TensorShape::reshape(size_t newNumDimensions)
                                     ^
matlab/src/bits/data.cu:603:51: style:inconclusive: Function 'reshape' argument 1 names different: declaration 'shape' definition 'newShape'. [funcArgNamesDifferent]
void vl::TensorShape::reshape(TensorShape const & newShape)
                                                  ^
matlab/src/bits/data.hpp:196:38: note: Function 'reshape' argument 1 names different: declaration 'shape' definition 'newShape'.
    void reshape(TensorShape const & shape) ; // same as operator=
                                     ^
matlab/src/bits/data.cu:603:51: note: Function 'reshape' argument 1 names different: declaration 'shape' definition 'newShape'.
void vl::TensorShape::reshape(TensorShape const & newShape)
                                                  ^
matlab/src/bits/datamex.hpp:48:5: style: Class 'MexTensor' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    MexTensor(MexContext & context) ;
    ^
matlab/src/bits/datamex.cu:191:38: style:inconclusive: Function 'initHelper' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'. [funcArgNamesDifferent]
vl::MexTensor::initHelper(DeviceType newDeviceType, DataType newDataType,
                                     ^
matlab/src/bits/datamex.hpp:72:41: note: Function 'initHelper' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'.
    vl::ErrorCode initHelper(DeviceType deviceType, DataType dataType, TensorShape const & shape, bool fillWithZeros = false) ;
                                        ^
matlab/src/bits/datamex.cu:191:38: note: Function 'initHelper' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'.
vl::MexTensor::initHelper(DeviceType newDeviceType, DataType newDataType,
                                     ^
matlab/src/bits/datamex.cu:191:62: style:inconclusive: Function 'initHelper' argument 2 names different: declaration 'dataType' definition 'newDataType'. [funcArgNamesDifferent]
vl::MexTensor::initHelper(DeviceType newDeviceType, DataType newDataType,
                                                             ^
matlab/src/bits/datamex.hpp:72:62: note: Function 'initHelper' argument 2 names different: declaration 'dataType' definition 'newDataType'.
    vl::ErrorCode initHelper(DeviceType deviceType, DataType dataType, TensorShape const & shape, bool fillWithZeros = false) ;
                                                             ^
matlab/src/bits/datamex.cu:191:62: note: Function 'initHelper' argument 2 names different: declaration 'dataType' definition 'newDataType'.
vl::MexTensor::initHelper(DeviceType newDeviceType, DataType newDataType,
                                                             ^
matlab/src/bits/datamex.cu:192:47: style:inconclusive: Function 'initHelper' argument 3 names different: declaration 'shape' definition 'newShape'. [funcArgNamesDifferent]
                          TensorShape const & newShape, bool fillWithZeros)
                                              ^
matlab/src/bits/datamex.hpp:72:92: note: Function 'initHelper' argument 3 names different: declaration 'shape' definition 'newShape'.
    vl::ErrorCode initHelper(DeviceType deviceType, DataType dataType, TensorShape const & shape, bool fillWithZeros = false) ;
                                                                                           ^
matlab/src/bits/datamex.cu:192:47: note: Function 'initHelper' argument 3 names different: declaration 'shape' definition 'newShape'.
                          TensorShape const & newShape, bool fillWithZeros)
                                              ^
matlab/src/bits/datamex.cu:276:32: style:inconclusive: Function 'init' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'. [funcArgNamesDifferent]
vl::MexTensor::init(DeviceType newDeviceType,
                               ^
matlab/src/bits/datamex.hpp:50:35: note: Function 'init' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'.
    vl::ErrorCode init(DeviceType deviceType, DataType dataType, TensorShape const & shape) ;
                                  ^
matlab/src/bits/datamex.cu:276:32: note: Function 'init' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'.
vl::MexTensor::init(DeviceType newDeviceType,
                               ^
matlab/src/bits/datamex.cu:277:30: style:inconclusive: Function 'init' argument 2 names different: declaration 'dataType' definition 'newDataType'. [funcArgNamesDifferent]
                    DataType newDataType,
                             ^
matlab/src/bits/datamex.hpp:50:56: note: Function 'init' argument 2 names different: declaration 'dataType' definition 'newDataType'.
    vl::ErrorCode init(DeviceType deviceType, DataType dataType, TensorShape const & shape) ;
                                                       ^
matlab/src/bits/datamex.cu:277:30: note: Function 'init' argument 2 names different: declaration 'dataType' definition 'newDataType'.
                    DataType newDataType,
                             ^
matlab/src/bits/datamex.cu:278:41: style:inconclusive: Function 'init' argument 3 names different: declaration 'shape' definition 'newShape'. [funcArgNamesDifferent]
                    TensorShape const & newShape)
                                        ^
matlab/src/bits/datamex.hpp:50:86: note: Function 'init' argument 3 names different: declaration 'shape' definition 'newShape'.
    vl::ErrorCode init(DeviceType deviceType, DataType dataType, TensorShape const & shape) ;
                                                                                     ^
matlab/src/bits/datamex.cu:278:41: note: Function 'init' argument 3 names different: declaration 'shape' definition 'newShape'.
                    TensorShape const & newShape)
                                        ^
matlab/src/bits/datamex.cu:284:41: style:inconclusive: Function 'initWithZeros' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'. [funcArgNamesDifferent]
vl::MexTensor::initWithZeros(DeviceType newDeviceType,
                                        ^
matlab/src/bits/datamex.hpp:51:44: note: Function 'initWithZeros' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'.
    vl::ErrorCode initWithZeros(DeviceType deviceType, DataType dataType, TensorShape const & shape) ;
                                           ^
matlab/src/bits/datamex.cu:284:41: note: Function 'initWithZeros' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'.
vl::MexTensor::initWithZeros(DeviceType newDeviceType,
                                        ^
matlab/src/bits/datamex.cu:285:39: style:inconclusive: Function 'initWithZeros' argument 2 names different: declaration 'dataType' definition 'newDataType'. [funcArgNamesDifferent]
                             DataType newDataType,
                                      ^
matlab/src/bits/datamex.hpp:51:65: note: Function 'initWithZeros' argument 2 names different: declaration 'dataType' definition 'newDataType'.
    vl::ErrorCode initWithZeros(DeviceType deviceType, DataType dataType, TensorShape const & shape) ;
                                                                ^
matlab/src/bits/datamex.cu:285:39: note: Function 'initWithZeros' argument 2 names different: declaration 'dataType' definition 'newDataType'.
                             DataType newDataType,
                                      ^
matlab/src/bits/datamex.cu:286:50: style:inconclusive: Function 'initWithZeros' argument 3 names different: declaration 'shape' definition 'newShape'. [funcArgNamesDifferent]
                             TensorShape const & newShape)
                                                 ^
matlab/src/bits/datamex.hpp:51:95: note: Function 'initWithZeros' argument 3 names different: declaration 'shape' definition 'newShape'.
    vl::ErrorCode initWithZeros(DeviceType deviceType, DataType dataType, TensorShape const & shape) ;
                                                                                              ^
matlab/src/bits/datamex.cu:286:50: note: Function 'initWithZeros' argument 3 names different: declaration 'shape' definition 'newShape'.
                             TensorShape const & newShape)
                                                 ^
matlab/src/bits/datamex.cu:292:41: style:inconclusive: Function 'initWithValue' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'. [funcArgNamesDifferent]
vl::MexTensor::initWithValue(DeviceType newDeviceType,
                                        ^
matlab/src/bits/datamex.hpp:52:44: note: Function 'initWithValue' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'.
    vl::ErrorCode initWithValue(DeviceType deviceType, DataType dataType, TensorShape const & shape, double value) ;
                                           ^
matlab/src/bits/datamex.cu:292:41: note: Function 'initWithValue' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'.
vl::MexTensor::initWithValue(DeviceType newDeviceType,
                                        ^
matlab/src/bits/datamex.cu:293:39: style:inconclusive: Function 'initWithValue' argument 2 names different: declaration 'dataType' definition 'newDataType'. [funcArgNamesDifferent]
                             DataType newDataType,
                                      ^
matlab/src/bits/datamex.hpp:52:65: note: Function 'initWithValue' argument 2 names different: declaration 'dataType' definition 'newDataType'.
    vl::ErrorCode initWithValue(DeviceType deviceType, DataType dataType, TensorShape const & shape, double value) ;
                                                                ^
matlab/src/bits/datamex.cu:293:39: note: Function 'initWithValue' argument 2 names different: declaration 'dataType' definition 'newDataType'.
                             DataType newDataType,
                                      ^
matlab/src/bits/datamex.cu:294:50: style:inconclusive: Function 'initWithValue' argument 3 names different: declaration 'shape' definition 'newShape'. [funcArgNamesDifferent]
                             TensorShape const & newShape,
                                                 ^
matlab/src/bits/datamex.hpp:52:95: note: Function 'initWithValue' argument 3 names different: declaration 'shape' definition 'newShape'.
    vl::ErrorCode initWithValue(DeviceType deviceType, DataType dataType, TensorShape const & shape, double value) ;
                                                                                              ^
matlab/src/bits/datamex.cu:294:50: note: Function 'initWithValue' argument 3 names different: declaration 'shape' definition 'newShape'.
                             TensorShape const & newShape,
                                                 ^
matlab/src/bits/datamex.cu:340:37: style:inconclusive: Function 'init' argument 1 names different: declaration 'array' definition 'array_'. [funcArgNamesDifferent]
vl::MexTensor::init(mxArray const * array_)
                                    ^
matlab/src/bits/datamex.hpp:49:40: note: Function 'init' argument 1 names different: declaration 'array' definition 'array_'.
    vl::ErrorCode init(mxArray const * array) ;
                                       ^
matlab/src/bits/datamex.cu:340:37: note: Function 'init' argument 1 names different: declaration 'array' definition 'array_'.
vl::MexTensor::init(mxArray const * array_)
                                    ^
matlab/src/bits/datamex.cu:305:32: style: Variable 'error' is assigned a value that is never used. [unreadVariable]
        case VLDT_Float: error = operations<vl::VLDT_CPU,float>::fill((float*)memory, n, (float)value) ; break ;
                               ^
matlab/src/bits/datamex.cu:307:33: style: Variable 'error' is assigned a value that is never used. [unreadVariable]
        case VLDT_Double: error = operations<vl::VLDT_CPU,double>::fill((double*)memory, n, (double)value) ; break ;
                                ^
matlab/src/bits/impl/bnorm_cpu.cpp:266:5: style: Label 'done' is not used. [unusedLabel]
    done:;
    ^
matlab/src/bits/impl/bnorm_cpu.cpp:79:10: style: Variable 'mass' is assigned a value that is never used. [unreadVariable]
  T mass = WH*num;
         ^
matlab/src/bits/impl/im2row_cpu.cpp:210:13: style: The scope of the variable 'x' can be reduced. [variableScope]
        int x ;
            ^
matlab/src/bits/impl/imread_helpers.hpp:468:44: style:inconclusive: Boolean expression '-0.5f<=delta' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
              h = (float)((-0.5f <= delta) & (delta < 0.5f)) ;
                                           ^
matlab/src/bits/mexutils.h:282:38: style: Array index 'di' is used before limits check. [arrayIndexThenCheck]
  for (di = 2 ; ((unsigned)dimensions[di] == 1) && di < numDimensions ; ++ di) ;
                                     ^
matlab/src/bits/impl/imread_gdiplus.cpp:206:3: warning: Class 'ImageReader' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
  impl = new vl::ImageReader::Impl() ;
  ^
matlab/src/bits/impl/imread_gdiplus.cpp:206:3: warning: Class 'ImageReader' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
  impl = new vl::ImageReader::Impl() ;
  ^
matlab/src/bits/imread.hpp:43:5: style: Class 'Image' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Image(ImageShape const & shape, float * memory = NULL) ;
    ^
matlab/src/bits/mexutils.h:302:13: style: The scope of the variable 'd' can be reduced. [variableScope]
    ssize_t d ;
            ^
matlab/src/bits/impl/imread_helpers.hpp:88:17: style: The scope of the variable 'rend' can be reduced. [variableScope]
        float * rend ;
                ^
matlab/src/bits/impl/imread_gdiplus.cpp:215:58: style:inconclusive: Function 'readPixels' argument 2 names different: declaration 'fileName' definition 'filename'. [funcArgNamesDifferent]
vl::ImageReader::readPixels(float * memory, char const * filename)
                                                         ^
matlab/src/bits/imread.hpp:59:59: note: Function 'readPixels' argument 2 names different: declaration 'fileName' definition 'filename'.
    vl::ErrorCode readPixels(float * memory, char const * fileName) ;
                                                          ^
matlab/src/bits/impl/imread_gdiplus.cpp:215:58: note: Function 'readPixels' argument 2 names different: declaration 'fileName' definition 'filename'.
vl::ImageReader::readPixels(float * memory, char const * filename)
                                                         ^
matlab/src/bits/impl/imread_gdiplus.cpp:221:45: style:inconclusive: Function 'readShape' argument 1 names different: declaration 'image' definition 'shape'. [funcArgNamesDifferent]
vl::ImageReader::readShape(vl::ImageShape & shape, char const * filename)
                                            ^
matlab/src/bits/imread.hpp:58:42: note: Function 'readShape' argument 1 names different: declaration 'image' definition 'shape'.
    vl::ErrorCode readShape(ImageShape & image, char const * fileName) ;
                                         ^
matlab/src/bits/impl/imread_gdiplus.cpp:221:45: note: Function 'readShape' argument 1 names different: declaration 'image' definition 'shape'.
vl::ImageReader::readShape(vl::ImageShape & shape, char const * filename)
                                            ^
matlab/src/bits/impl/imread_gdiplus.cpp:221:65: style:inconclusive: Function 'readShape' argument 2 names different: declaration 'fileName' definition 'filename'. [funcArgNamesDifferent]
vl::ImageReader::readShape(vl::ImageShape & shape, char const * filename)
                                                                ^
matlab/src/bits/imread.hpp:58:62: note: Function 'readShape' argument 2 names different: declaration 'fileName' definition 'filename'.
    vl::ErrorCode readShape(ImageShape & image, char const * fileName) ;
                                                             ^
matlab/src/bits/impl/imread_gdiplus.cpp:221:65: note: Function 'readShape' argument 2 names different: declaration 'fileName' definition 'filename'.
vl::ImageReader::readShape(vl::ImageShape & shape, char const * filename)
                                                                ^
matlab/src/bits/mexutils.h:110:16: warning:inconclusive: Found suspicious operator '||' [constStatement]
  errorMessage || (errorMessage = vlmxErrorMessageTable[2*errorCode+1]) ;
               ^
matlab/src/bits/impl/imread_gdiplus.cpp:181:23: style: Variable 'error' is assigned a value that is never used. [unreadVariable]
  vl::ErrorCode error = vl::VLE_Success ;
                      ^
matlab/src/bits/impl/imread_helpers.hpp:365:17: style: The scope of the variable 'rend' can be reduced. [variableScope]
        float * rend ;
                ^
matlab/src/bits/impl/imread_libjpeg.cpp:54:24: warning: Member variable 'Impl::onJpegError' is not initialized in the constructor. [uninitMemberVar]
vl::ImageReader::Impl::Impl()
                       ^
matlab/src/bits/impl/imread_libjpeg.cpp:54:24: warning: Member variable 'Impl::jpegLastErrorMsg' is not initialized in the constructor. [uninitMemberVar]
vl::ImageReader::Impl::Impl()
                       ^
matlab/src/bits/impl/imread_libjpeg.cpp:216:3: warning: Class 'ImageReader' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
  impl = new vl::ImageReader::Impl() ;
  ^
matlab/src/bits/impl/imread_libjpeg.cpp:216:3: warning: Class 'ImageReader' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
  impl = new vl::ImageReader::Impl() ;
  ^
matlab/src/bits/impl/imread_libjpeg.cpp:225:58: style:inconclusive: Function 'readPixels' argument 2 names different: declaration 'fileName' definition 'filename'. [funcArgNamesDifferent]
vl::ImageReader::readPixels(float * memory, char const * filename)
                                                         ^
matlab/src/bits/imread.hpp:59:59: note: Function 'readPixels' argument 2 names different: declaration 'fileName' definition 'filename'.
    vl::ErrorCode readPixels(float * memory, char const * fileName) ;
                                                          ^
matlab/src/bits/impl/imread_libjpeg.cpp:225:58: note: Function 'readPixels' argument 2 names different: declaration 'fileName' definition 'filename'.
vl::ImageReader::readPixels(float * memory, char const * filename)
                                                         ^
matlab/src/bits/impl/imread_libjpeg.cpp:231:45: style:inconclusive: Function 'readShape' argument 1 names different: declaration 'image' definition 'shape'. [funcArgNamesDifferent]
vl::ImageReader::readShape(vl::ImageShape & shape, char const * filename)
                                            ^
matlab/src/bits/imread.hpp:58:42: note: Function 'readShape' argument 1 names different: declaration 'image' definition 'shape'.
    vl::ErrorCode readShape(ImageShape & image, char const * fileName) ;
                                         ^
matlab/src/bits/impl/imread_libjpeg.cpp:231:45: note: Function 'readShape' argument 1 names different: declaration 'image' definition 'shape'.
vl::ImageReader::readShape(vl::ImageShape & shape, char const * filename)
                                            ^
matlab/src/bits/impl/imread_libjpeg.cpp:231:65: style:inconclusive: Function 'readShape' argument 2 names different: declaration 'fileName' definition 'filename'. [funcArgNamesDifferent]
vl::ImageReader::readShape(vl::ImageShape & shape, char const * filename)
                                                                ^
matlab/src/bits/imread.hpp:58:62: note: Function 'readShape' argument 2 names different: declaration 'fileName' definition 'filename'.
    vl::ErrorCode readShape(ImageShape & image, char const * fileName) ;
                                                             ^
matlab/src/bits/impl/imread_libjpeg.cpp:231:65: note: Function 'readShape' argument 2 names different: declaration 'fileName' definition 'filename'.
vl::ImageReader::readShape(vl::ImageShape & shape, char const * filename)
                                                                ^
matlab/src/bits/impl/imread_libjpeg.cpp:163:7: style: Unused variable: row_stride [unusedVariable]
  int row_stride ;
      ^
matlab/src/bits/imread.hpp:58:19: performance:inconclusive: Technically the member function 'vl::ImageReader::readShape' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    vl::ErrorCode readShape(ImageShape & image, char const * fileName) ;
                  ^
matlab/src/bits/impl/imread_quartz.cpp:154:18: note: Technically the member function 'vl::ImageReader::readShape' can be static (but you may consider moving to unnamed namespace).
vl::ImageReader::readShape(vl::ImageShape & shape, const char * fileName)
                 ^
matlab/src/bits/imread.hpp:58:19: note: Technically the member function 'vl::ImageReader::readShape' can be static (but you may consider moving to unnamed namespace).
    vl::ErrorCode readShape(ImageShape & image, char const * fileName) ;
                  ^
matlab/src/bits/imread.hpp:59:19: style:inconclusive: Technically the member function 'vl::ImageReader::readPixels' can be const. [functionConst]
    vl::ErrorCode readPixels(float * memory, char const * fileName) ;
                  ^
matlab/src/bits/impl/imread_quartz.cpp:51:18: note: Technically the member function 'vl::ImageReader::readPixels' can be const.
vl::ImageReader::readPixels(float * memory, const char * fileName)
                 ^
matlab/src/bits/imread.hpp:59:19: note: Technically the member function 'vl::ImageReader::readPixels' can be const.
    vl::ErrorCode readPixels(float * memory, char const * fileName) ;
                  ^
matlab/src/bits/impl/imread_quartz.cpp:37:3: warning: Class 'ImageReader' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
: impl(new Impl())
  ^
matlab/src/bits/impl/imread_quartz.cpp:37:3: warning: Class 'ImageReader' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
: impl(new Impl())
  ^
matlab/src/bits/impl/imread_quartz.cpp:154:45: style:inconclusive: Function 'readShape' argument 1 names different: declaration 'image' definition 'shape'. [funcArgNamesDifferent]
vl::ImageReader::readShape(vl::ImageShape & shape, const char * fileName)
                                            ^
matlab/src/bits/imread.hpp:58:42: note: Function 'readShape' argument 1 names different: declaration 'image' definition 'shape'.
    vl::ErrorCode readShape(ImageShape & image, char const * fileName) ;
                                         ^
matlab/src/bits/impl/imread_quartz.cpp:154:45: note: Function 'readShape' argument 1 names different: declaration 'image' definition 'shape'.
vl::ImageReader::readShape(vl::ImageShape & shape, const char * fileName)
                                            ^
matlab/src/bits/impl/normalize_cpu.cpp:55:15: portability: Casting from double * to signed long long * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
  int_t ix = *(int_t*)&x - offset ;
              ^
matlab/src/bits/impl/normalize_cpu.cpp:58:17: portability: Casting between signed long long * and double * which have an incompatible binary data representation. [invalidPointerCast]
  double mx = *((double*)&imx) - 1 ;
                ^
matlab/src/bits/impl/normalize_cpu.cpp:72:5: portability: Casting from double * to signed long long * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
  *((int_t*)&z) = (int_t)(tz * (1LL<<52)) + offset ;
    ^
matlab/src/bits/impl/normalize_cpu.cpp:101:15: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
  int_t ix = *(int_t*)&x - offset ;
              ^
matlab/src/bits/impl/normalize_cpu.cpp:104:16: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
  float mx = *((float*)&imx) - 1 ;
               ^
matlab/src/bits/impl/normalize_cpu.cpp:115:5: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
  *((int_t*)&z) = (int_t)(tz * (1<<23)) + offset ;
    ^
matlab/src/bits/impl/normalize_cpu.cpp:45:10: style: Variable 'z' is not assigned a value. [unassignedVariable]
  double z ;
         ^
matlab/src/bits/impl/normalize_cpu.cpp:91:9: style: Variable 'z' is not assigned a value. [unassignedVariable]
  float z ;
        ^
matlab/src/bits/impl/normalize_cpu.cpp:239:14: style: Unused variable: q [unusedVariable]
      int t, q ;
             ^
matlab/src/bits/impl/normalize_cpu.cpp:82:16: portability: Casting from double * to signed long long * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
  int_t ai = *((int_t*)&a) ;
               ^
matlab/src/bits/impl/normalize_cpu.cpp:83:5: portability: Casting from double * to signed long long * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
  *((int_t*)&z) = (int_t)(b * (ai - offset)) + offset ;
    ^
matlab/src/bits/impl/normalize_cpu.cpp:124:16: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
  int_t ai = *((int_t*)&a) ;
               ^
matlab/src/bits/impl/normalize_cpu.cpp:125:5: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
  *((int_t*)&z) = (int_t)(b * (ai - offset)) + offset ;
    ^
matlab/src/bits/impl/normalize_cpu.cpp:79:10: style: Variable 'z' is not assigned a value. [unassignedVariable]
  double z ;
         ^
matlab/src/bits/impl/normalize_cpu.cpp:121:9: style: Variable 'z' is not assigned a value. [unassignedVariable]
  float z ;
        ^
matlab/src/bits/impl/pooling_cpu.cpp:88:8: style:inconclusive: Member variable 'acc_sum::derOutput' is in the wrong place in the initializer list. [initializerList]
  type derOutput ;
       ^
matlab/src/bits/impl/pooling_cpu.cpp:69:3: note: Member variable 'acc_sum::derOutput' is in the wrong place in the initializer list.
  derOutput(derOutput)
  ^
matlab/src/bits/impl/pooling_cpu.cpp:88:8: note: Member variable 'acc_sum::derOutput' is in the wrong place in the initializer list.
  type derOutput ;
       ^
matlab/src/bits/impl/pooling_cpu.cpp:77:15: style:inconclusive: Technically the member function 'acc_sum::accumulate_backward' can be const. [functionConst]
  inline void accumulate_backward(type const* data, type* derDataPt) {
              ^
matlab/src/bits/impl/pooling_cpu.cpp:85:15: performance:inconclusive: Technically the member function 'acc_sum::done_backward' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  inline void done_backward() const { }
              ^
matlab/src/bits/impl/roipooling_cpu.cpp:94:8: style:inconclusive: Member variable 'acc_sum::derOutput' is in the wrong place in the initializer list. [initializerList]
  type derOutput ;
       ^
matlab/src/bits/impl/roipooling_cpu.cpp:76:3: note: Member variable 'acc_sum::derOutput' is in the wrong place in the initializer list.
  derOutput(derOutput)
  ^
matlab/src/bits/impl/roipooling_cpu.cpp:94:8: note: Member variable 'acc_sum::derOutput' is in the wrong place in the initializer list.
  type derOutput ;
       ^
matlab/src/bits/impl/roipooling_cpu.cpp:83:15: style:inconclusive: Technically the member function 'acc_sum::accumulate_backward' can be const. [functionConst]
  inline void accumulate_backward(type const* data, type* derDataPt) {
              ^
matlab/src/bits/impl/roipooling_cpu.cpp:91:15: performance:inconclusive: Technically the member function 'acc_sum::done_backward' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  inline void done_backward() const { }
              ^
matlab/src/bits/impl/tinythread.h:539:31: style:inconclusive: Technically the member function 'tthread::thread::native_handle' can be const. [functionConst]
    inline native_handle_type native_handle()
                              ^
matlab/src/bits/impl/tinythread.h:579:5: style: Class 'id' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    id(unsigned long int aId) : mId(aId) {};
    ^
matlab/src/bits/impl/tinythread.cpp:164:29: style: C-style pointer casting [cstyleCast]
  _thread_start_info * ti = (_thread_start_info *) aArg;
                            ^
matlab/src/bits/impl/tinythread.cpp:135:28: style: The scope of the variable 'idCount' can be reduced. [variableScope]
  static unsigned long int idCount(1);
                           ^
matlab/src/bits/impl/tinythread.cpp:139:30: performance: Searching before insertion is not necessary. [stlFindInsert]
    idMap[aHandle] = idCount ++;
                             ^
matlab/src/bits/impl/tinythread.cpp:279:0: information: Skipping configuration '_SC_NPROCESSORS_ONLN' since the value of '_SC_NPROCESSORS_ONLN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  return (int) sysconf(_SC_NPROCESSORS_ONLN);
^
matlab/src/bits/impl/tinythread.cpp:281:0: information: Skipping configuration '_SC_NPROC_ONLN' since the value of '_SC_NPROC_ONLN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  return (int) sysconf(_SC_NPROC_ONLN);
^
matlab/src/bits/imread.cpp:39:25: style:inconclusive: Boolean expression 'height==im.height' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  (height == im.height) &
                        ^
matlab/src/bits/imread.cpp:40:23: style:inconclusive: Boolean expression 'depth==im.depth' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  (width == im.width) &
                      ^
matlab/src/bits/imread.hpp:32:10: style:inconclusive: Technically the member function 'vl::ImageShape::operator==' can be const. [functionConst]
    bool operator == (ImageShape const & im) ;
         ^
matlab/src/bits/imread.cpp:36:22: note: Technically the member function 'vl::ImageShape::operator==' can be const.
bool vl::ImageShape::operator == (vl::ImageShape const & im)
                     ^
matlab/src/bits/imread.hpp:32:10: note: Technically the member function 'vl::ImageShape::operator==' can be const.
    bool operator == (ImageShape const & im) ;
         ^
matlab/src/bits/nnbias.cu:82:1: style: Label 'done' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
done:
^
matlab/src/bits/nnbias.cu:135:1: style: Label 'done' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
done:
^
matlab/src/bits/nnbnorm.cu:68:32: style:inconclusive: Function 'nnbnorm_forward' argument 5 names different: declaration 'filters' definition 'multipliers'. [funcArgNamesDifferent]
                    vl::Tensor multipliers,
                               ^
matlab/src/bits/nnbnorm.hpp:28:30: note: Function 'nnbnorm_forward' argument 5 names different: declaration 'filters' definition 'multipliers'.
                  vl::Tensor filters,
                             ^
matlab/src/bits/nnbnorm.cu:68:32: note: Function 'nnbnorm_forward' argument 5 names different: declaration 'filters' definition 'multipliers'.
                    vl::Tensor multipliers,
                               ^
matlab/src/bits/nnbnorm.cu:127:46: style:inconclusive: Function 'nnbnorm_forward_given_moments' argument 5 names different: declaration 'filters' definition 'multipliers'. [funcArgNamesDifferent]
                                  vl::Tensor multipliers,
                                             ^
matlab/src/bits/nnbnorm.hpp:38:44: note: Function 'nnbnorm_forward_given_moments' argument 5 names different: declaration 'filters' definition 'multipliers'.
                                vl::Tensor filters,
                                           ^
matlab/src/bits/nnbnorm.cu:127:46: note: Function 'nnbnorm_forward_given_moments' argument 5 names different: declaration 'filters' definition 'multipliers'.
                                  vl::Tensor multipliers,
                                             ^
matlab/src/bits/nnbnorm.cu:192:33: style:inconclusive: Function 'nnbnorm_backward' argument 3 names different: declaration 'derFilters' definition 'derMultipliers'. [funcArgNamesDifferent]
                     vl::Tensor derMultipliers,
                                ^
matlab/src/bits/nnbnorm.hpp:44:31: note: Function 'nnbnorm_backward' argument 3 names different: declaration 'derFilters' definition 'derMultipliers'.
                   vl::Tensor derFilters,
                              ^
matlab/src/bits/nnbnorm.cu:192:33: note: Function 'nnbnorm_backward' argument 3 names different: declaration 'derFilters' definition 'derMultipliers'.
                     vl::Tensor derMultipliers,
                                ^
matlab/src/bits/nnbnorm.cu:193:33: style:inconclusive: Function 'nnbnorm_backward' argument 4 names different: declaration 'derBiaises' definition 'derBiases'. [funcArgNamesDifferent]
                     vl::Tensor derBiases,
                                ^
matlab/src/bits/nnbnorm.hpp:45:31: note: Function 'nnbnorm_backward' argument 4 names different: declaration 'derBiaises' definition 'derBiases'.
                   vl::Tensor derBiaises,
                              ^
matlab/src/bits/nnbnorm.cu:193:33: note: Function 'nnbnorm_backward' argument 4 names different: declaration 'derBiaises' definition 'derBiases'.
                     vl::Tensor derBiases,
                                ^
matlab/src/bits/nnbnorm.cu:196:33: style:inconclusive: Function 'nnbnorm_backward' argument 7 names different: declaration 'filters' definition 'multipliers'. [funcArgNamesDifferent]
                     vl::Tensor multipliers,
                                ^
matlab/src/bits/nnbnorm.hpp:48:31: note: Function 'nnbnorm_backward' argument 7 names different: declaration 'filters' definition 'multipliers'.
                   vl::Tensor filters,
                              ^
matlab/src/bits/nnbnorm.cu:196:33: note: Function 'nnbnorm_backward' argument 7 names different: declaration 'filters' definition 'multipliers'.
                     vl::Tensor multipliers,
                                ^
matlab/src/bits/nnbnorm.cu:252:47: style:inconclusive: Function 'nnbnorm_backward_given_moments' argument 3 names different: declaration 'derFilters' definition 'derMultipliers'. [funcArgNamesDifferent]
                                   vl::Tensor derMultipliers,
                                              ^
matlab/src/bits/nnbnorm.hpp:56:45: note: Function 'nnbnorm_backward_given_moments' argument 3 names different: declaration 'derFilters' definition 'derMultipliers'.
                                 vl::Tensor derFilters,
                                            ^
matlab/src/bits/nnbnorm.cu:252:47: note: Function 'nnbnorm_backward_given_moments' argument 3 names different: declaration 'derFilters' definition 'derMultipliers'.
                                   vl::Tensor derMultipliers,
                                              ^
matlab/src/bits/nnbnorm.cu:253:47: style:inconclusive: Function 'nnbnorm_backward_given_moments' argument 4 names different: declaration 'derBiaises' definition 'derBiases'. [funcArgNamesDifferent]
                                   vl::Tensor derBiases,
                                              ^
matlab/src/bits/nnbnorm.hpp:57:45: note: Function 'nnbnorm_backward_given_moments' argument 4 names different: declaration 'derBiaises' definition 'derBiases'.
                                 vl::Tensor derBiaises,
                                            ^
matlab/src/bits/nnbnorm.cu:253:47: note: Function 'nnbnorm_backward_given_moments' argument 4 names different: declaration 'derBiaises' definition 'derBiases'.
                                   vl::Tensor derBiases,
                                              ^
matlab/src/bits/nnbnorm.cu:256:47: style:inconclusive: Function 'nnbnorm_backward_given_moments' argument 7 names different: declaration 'filters' definition 'multipliers'. [funcArgNamesDifferent]
                                   vl::Tensor multipliers,
                                              ^
matlab/src/bits/nnbnorm.hpp:60:45: note: Function 'nnbnorm_backward_given_moments' argument 7 names different: declaration 'filters' definition 'multipliers'.
                                 vl::Tensor filters,
                                            ^
matlab/src/bits/nnbnorm.cu:256:47: note: Function 'nnbnorm_backward_given_moments' argument 7 names different: declaration 'filters' definition 'multipliers'.
                                   vl::Tensor multipliers,
                                              ^
matlab/src/bits/nnconv.cu:110:1: style: Label 'done' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
done:
^
matlab/src/bits/nnconv.cu:189:1: style: Label 'done' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
done:
^
matlab/src/bits/nnfullyconnected.cu:71:10: style: Local variable 'beta' shadows outer variable [shadowVariable]
    type beta = 1 ;
         ^
matlab/src/bits/nnfullyconnected.cu:34:8: note: Shadowed declaration
  type beta = 0 ;
       ^
matlab/src/bits/nnfullyconnected.cu:71:10: note: Shadow variable
    type beta = 1 ;
         ^
matlab/src/bits/nnfullyconnected.cu:188:37: performance: Function parameter 'output' should be passed by const reference. [passedByValue]
                             Tensor output,
                                    ^
matlab/src/bits/nnfullyconnected.cu:189:37: performance: Function parameter 'data' should be passed by const reference. [passedByValue]
                             Tensor data,
                                    ^
matlab/src/bits/nnfullyconnected.cu:190:37: performance: Function parameter 'filters' should be passed by const reference. [passedByValue]
                             Tensor filters,
                                    ^
matlab/src/bits/nnfullyconnected.cu:191:37: performance: Function parameter 'biases' should be passed by const reference. [passedByValue]
                             Tensor biases)
                                    ^
matlab/src/bits/nnfullyconnected.cu:226:42: performance: Function parameter 'derData' should be passed by const reference. [passedByValue]
                              vl::Tensor derData,
                                         ^
matlab/src/bits/nnfullyconnected.cu:227:42: performance: Function parameter 'derFilters' should be passed by const reference. [passedByValue]
                              vl::Tensor derFilters,
                                         ^
matlab/src/bits/nnfullyconnected.cu:228:42: performance: Function parameter 'derBiases' should be passed by const reference. [passedByValue]
                              vl::Tensor derBiases,
                                         ^
matlab/src/bits/nnfullyconnected.cu:229:42: performance: Function parameter 'data' should be passed by const reference. [passedByValue]
                              vl::Tensor data,
                                         ^
matlab/src/bits/nnfullyconnected.cu:230:42: performance: Function parameter 'filters' should be passed by const reference. [passedByValue]
                              vl::Tensor filters,
                                         ^
matlab/src/bits/nnfullyconnected.cu:231:42: performance: Function parameter 'derOutput' should be passed by const reference. [passedByValue]
                              vl::Tensor derOutput)
                                         ^
matlab/src/bits/nnpooling.cu:141:0: error: failed to expand 'DISPATCH3', Wrong number of parameters for macro 'IF_DOUBLE'. [preprocessorErrorDirective]
#define DISPATCH2(deviceType, op) \
^
matlab/src/bits/nnpooling.cpp:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. Use -v for more details. [noValidConfiguration]

^
matlab/src/bits/nnroipooling.cu:110:0: error: failed to expand 'DISPATCH3', Wrong number of parameters for macro 'IF_DOUBLE'. [preprocessorErrorDirective]
#define DISPATCH2(deviceType, op) \
^
matlab/src/bits/nnroipooling.cpp:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. Use -v for more details. [noValidConfiguration]

^
matlab/src/bits/nnsubsample.cu:155:32: performance: Function parameter 'output' should be passed by const reference. [passedByValue]
                        Tensor output,
                               ^
matlab/src/bits/nnsubsample.cu:156:32: performance: Function parameter 'data' should be passed by const reference. [passedByValue]
                        Tensor data,
                               ^
matlab/src/bits/nnsubsample.cu:157:32: performance: Function parameter 'biases' should be passed by const reference. [passedByValue]
                        Tensor biases,
                               ^
matlab/src/bits/nnsubsample.cu:198:37: performance: Function parameter 'derData' should be passed by const reference. [passedByValue]
                         vl::Tensor derData,
                                    ^
matlab/src/bits/nnsubsample.cu:199:37: performance: Function parameter 'derBiases' should be passed by const reference. [passedByValue]
                         vl::Tensor derBiases,
                                    ^
matlab/src/bits/nnsubsample.cu:200:37: performance: Function parameter 'derOutput' should be passed by const reference. [passedByValue]
                         vl::Tensor derOutput,
                                    ^
matlab/src/vl_imreadjpeg.cpp:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 16 configurations. Use --force to check all configurations. [toomanyconfigs]

^
matlab/src/vl_imreadjpeg.cu:272:3: warning: memset() called to fill 0 bytes. [memsetZeroBytes]
  memset(errorMessage,sizeof(errorMessage),0) ;
  ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::nextItem' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::resizeHeight' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::resizeWidth' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::average' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::contrastDeviation' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::saturationDeviation' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::brightnessDeviation' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::minCropAnisotropy' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::maxCropAnisotropy' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::minCropSize' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::maxCropSize' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::cropLocation' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::flipMode' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::filterType' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:293:8: warning: Member variable 'Batch::gpuDevice' is not initialized in the constructor. [uninitMemberVar]
Batch::Batch(vl::MexContext & context)
       ^
matlab/src/vl_imreadjpeg.cu:263:14: warning: Member variable 'Item::array' is not initialized in the constructor. [uninitMemberVar]
Batch::Item::Item(Batch const & batch)
             ^
matlab/src/vl_imreadjpeg.cu:263:14: warning: Member variable 'Item::index' is not initialized in the constructor. [uninitMemberVar]
Batch::Item::Item(Batch const & batch)
             ^
matlab/src/vl_imreadjpeg.cu:263:14: warning: Member variable 'Item::outputWidth' is not initialized in the constructor. [uninitMemberVar]
Batch::Item::Item(Batch const & batch)
             ^
matlab/src/vl_imreadjpeg.cu:263:14: warning: Member variable 'Item::outputHeight' is not initialized in the constructor. [uninitMemberVar]
Batch::Item::Item(Batch const & batch)
             ^
matlab/src/vl_imreadjpeg.cu:263:14: warning: Member variable 'Item::outputNumChannels' is not initialized in the constructor. [uninitMemberVar]
Batch::Item::Item(Batch const & batch)
             ^
matlab/src/vl_imreadjpeg.cu:263:14: warning: Member variable 'Item::cropWidth' is not initialized in the constructor. [uninitMemberVar]
Batch::Item::Item(Batch const & batch)
             ^
matlab/src/vl_imreadjpeg.cu:263:14: warning: Member variable 'Item::cropHeight' is not initialized in the constructor. [uninitMemberVar]
Batch::Item::Item(Batch const & batch)
             ^
matlab/src/vl_imreadjpeg.cu:263:14: warning: Member variable 'Item::cropOffsetX' is not initialized in the constructor. [uninitMemberVar]
Batch::Item::Item(Batch const & batch)
             ^
matlab/src/vl_imreadjpeg.cu:263:14: warning: Member variable 'Item::cropOffsetY' is not initialized in the constructor. [uninitMemberVar]
Batch::Item::Item(Batch const & batch)
             ^
matlab/src/vl_imreadjpeg.cu:263:14: warning: Member variable 'Item::filterType' is not initialized in the constructor. [uninitMemberVar]
Batch::Item::Item(Batch const & batch)
             ^
matlab/src/vl_imreadjpeg.cu:263:14: warning: Member variable 'Item::brightnessShift' is not initialized in the constructor. [uninitMemberVar]
Batch::Item::Item(Batch const & batch)
             ^
matlab/src/vl_imreadjpeg.cu:263:14: warning: Member variable 'Item::contrastShift' is not initialized in the constructor. [uninitMemberVar]
Batch::Item::Item(Batch const & batch)
             ^
matlab/src/vl_imreadjpeg.cu:263:14: warning: Member variable 'Item::saturationShift' is not initialized in the constructor. [uninitMemberVar]
Batch::Item::Item(Batch const & batch)
             ^
matlab/src/vl_imreadjpeg.cu:822:13: warning: Member variable 'ReaderTask::index' is not initialized in the constructor. [uninitMemberVar]
ReaderTask::ReaderTask()
            ^
matlab/src/vl_imreadjpeg.cu:822:13: warning: Member variable 'ReaderTask::gpuDevice' is not initialized in the constructor. [uninitMemberVar]
ReaderTask::ReaderTask()
            ^
matlab/src/vl_imreadjpeg.cu:224:8: style:inconclusive: Member variable 'Batch::quit' is in the wrong place in the initializer list. [initializerList]
  bool quit ;
       ^
matlab/src/vl_imreadjpeg.cu:297:3: note: Member variable 'Batch::quit' is in the wrong place in the initializer list.
  quit(true),
  ^
matlab/src/vl_imreadjpeg.cu:224:8: note: Member variable 'Batch::quit' is in the wrong place in the initializer list.
  bool quit ;
       ^
matlab/src/vl_imreadjpeg.cu:230:22: style:inconclusive: Member variable 'Batch::packingMethod' is in the wrong place in the initializer list. [initializerList]
  enum PackingMethod packingMethod ;
                     ^
matlab/src/vl_imreadjpeg.cu:299:3: note: Member variable 'Batch::packingMethod' is in the wrong place in the initializer list.
  packingMethod(individualArrays),
  ^
matlab/src/vl_imreadjpeg.cu:230:22: note: Member variable 'Batch::packingMethod' is in the wrong place in the initializer list.
  enum PackingMethod packingMethod ;
                     ^
matlab/src/vl_imreadjpeg.cu:228:7: style:inconclusive: Member variable 'Batch::numReturnedItems' is in the wrong place in the initializer list. [initializerList]
  int numReturnedItems ;
      ^
matlab/src/vl_imreadjpeg.cu:301:3: note: Member variable 'Batch::numReturnedItems' is in the wrong place in the initializer list.
  numReturnedItems(0),
  ^
matlab/src/vl_imreadjpeg.cu:228:7: note: Member variable 'Batch::numReturnedItems' is in the wrong place in the initializer list.
  int numReturnedItems ;
      ^
matlab/src/vl_imreadjpeg.cu:149:10: style:inconclusive: Member variable 'Item::borrowed' is in the wrong place in the initializer list. [initializerList]
    bool borrowed ;
         ^
matlab/src/vl_imreadjpeg.cu:267:3: note: Member variable 'Item::borrowed' is in the wrong place in the initializer list.
  borrowed(false),
  ^
matlab/src/vl_imreadjpeg.cu:149:10: note: Member variable 'Item::borrowed' is in the wrong place in the initializer list.
    bool borrowed ;
         ^
matlab/src/vl_imreadjpeg.cu:147:19: style:inconclusive: Member variable 'Item::error' is in the wrong place in the initializer list. [initializerList]
    vl::ErrorCode error ;
                  ^
matlab/src/vl_imreadjpeg.cu:268:3: note: Member variable 'Item::error' is in the wrong place in the initializer list.
  error(vl::VLE_Success),
  ^
matlab/src/vl_imreadjpeg.cu:147:19: note: Member variable 'Item::error' is in the wrong place in the initializer list.
    vl::ErrorCode error ;
                  ^
matlab/src/vl_imreadjpeg.cu:141:7: style:inconclusive: Member variable 'Item::state' is in the wrong place in the initializer list. [initializerList]
    } state ;
      ^
matlab/src/vl_imreadjpeg.cu:269:3: note: Member variable 'Item::state' is in the wrong place in the initializer list.
  state(ready),
  ^
matlab/src/vl_imreadjpeg.cu:141:7: note: Member variable 'Item::state' is in the wrong place in the initializer list.
    } state ;
      ^
matlab/src/vl_imreadjpeg.cu:188:3: style: Class 'Batch' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Batch(vl::MexContext & context) ;
  ^
matlab/src/vl_imreadjpeg.cu:168:5: style: Struct 'Item' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Item(Batch const & batch) ;
    ^
matlab/src/vl_imreadjpeg.cu:819:4: style: C-style pointer casting [cstyleCast]
  ((ReaderTask*)thing)->entryPoint() ;
   ^
matlab/src/vl_imreadjpeg.cu:1334:9: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        break ;
        ^
matlab/src/vl_imreadjpeg.cu:746:16: style: Local variable 'i' shadows outer variable [shadowVariable]
      for (int i = 0 ; i < numChannels ; ++i) { w[i] = vl::randn() ; }
               ^
matlab/src/vl_imreadjpeg.cu:629:12: note: Shadowed declaration
  for (int i = 0 ; i < getNumberOfItems() ; ++ i) {
           ^
matlab/src/vl_imreadjpeg.cu:746:16: note: Shadow variable
      for (int i = 0 ; i < numChannels ; ++i) { w[i] = vl::randn() ; }
               ^
matlab/src/vl_imreadjpeg.cu:747:16: style: Local variable 'i' shadows outer variable [shadowVariable]
      for (int i = 0 ; i < numChannels ; ++i) {
               ^
matlab/src/vl_imreadjpeg.cu:629:12: note: Shadowed declaration
  for (int i = 0 ; i < getNumberOfItems() ; ++ i) {
           ^
matlab/src/vl_imreadjpeg.cu:747:16: note: Shadow variable
      for (int i = 0 ; i < numChannels ; ++i) {
               ^
matlab/src/vl_imreadjpeg.cu:1377:19: style: Local variable 'error' shadows outer variable [shadowVariable]
    vl::ErrorCode error = readers[r]->init(&batch, r) ;
                  ^
matlab/src/vl_imreadjpeg.cu:1118:17: note: Shadowed declaration
  vl::ErrorCode error ;
                ^
matlab/src/vl_imreadjpeg.cu:1377:19: note: Shadow variable
    vl::ErrorCode error = readers[r]->init(&batch, r) ;
                  ^
matlab/src/vl_imreadjpeg_old.cpp:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 16 configurations. Use --force to check all configurations. [toomanyconfigs]

^
matlab/src/vl_nnbilinearsampler.cu:142:22: style: Variable 'inHeight' is assigned a value that is never used. [unreadVariable]
  const int inHeight = data.getHeight(); // spatial dimension 1
                     ^
matlab/src/vl_nnbilinearsampler.cu:143:21: style: Variable 'inWidth' is assigned a value that is never used. [unreadVariable]
  const int inWidth = data.getWidth(); // spatial dimension 2
                    ^
matlab/src/vl_nnbnorm.cu:210:25: style:inconclusive: Boolean expression 'returnMomentsMode' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  if (returnMomentsMode & !givenMomentsMode) {
                        ^
matlab/src/vl_nnbnorm.cu:210:25: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (returnMomentsMode & !givenMomentsMode) {
                        ^
matlab/src/vl_nnbnorm.cu:221:9: style: The if condition is the same as the previous if condition [duplicateCondition]
    if (computeDerMultipliers) {
        ^
matlab/src/vl_nnbnorm.cu:80:25: note: 'computeDerData' is assigned value 'true' here.
  bool computeDerData = true ;
                        ^
matlab/src/vl_nnbnorm.cu:81:32: note: 'computeDerMultipliers' is assigned value 'true' here.
  bool computeDerMultipliers = true ;
                               ^
matlab/src/vl_nnbnorm.cu:218:9: note: First condition
    if (computeDerData) {
        ^
matlab/src/vl_nnbnorm.cu:221:9: note: Second condition
    if (computeDerMultipliers) {
        ^
matlab/src/vl_nnbnorm.cu:224:9: style: The if condition is the same as the previous if condition [duplicateCondition]
    if (computeDerBiases) {
        ^
matlab/src/vl_nnbnorm.cu:81:32: note: 'computeDerMultipliers' is assigned value 'true' here.
  bool computeDerMultipliers = true ;
                               ^
matlab/src/vl_nnbnorm.cu:82:27: note: 'computeDerBiases' is assigned value 'true' here.
  bool computeDerBiases = true ;
                          ^
matlab/src/vl_nnbnorm.cu:221:9: note: First condition
    if (computeDerMultipliers) {
        ^
matlab/src/vl_nnbnorm.cu:224:9: note: Second condition
    if (computeDerBiases) {
        ^
matlab/src/vl_nnconv.cu:517:46: style:inconclusive: Boolean expression 'computeDerFilters' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
    out[OUT_DERFILTERS] = (computeDerFilters & hasFilters)? derFilters.relinquish() : mxCreateNumericMatrix(0,0,classID,mxREAL) ;
                                             ^
matlab/src/vl_nnconv.cu:518:44: style:inconclusive: Boolean expression 'computederBiases' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
    out[OUT_DERBIASES] = (computederBiases & hasBiases) ? derBiases.relinquish() : mxCreateNumericMatrix(0,0,classID,mxREAL) ;
                                           ^
matlab/src/vl_nnconvt.cu:419:44: style:inconclusive: Boolean expression 'computederBiases' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
    out[OUT_DERBIASES] = (computederBiases & hasBiases) ? derBiases.relinquish() : mxCreateNumericMatrix(0,0,classID,mxREAL) ;
                                           ^
matlab/src/vl_nnpool.cu:263:5: style:inconclusive: Found duplicate branches for 'if' and 'else'. [duplicateBranch]
    if (data.getDeviceType() == vl::VLDT_GPU) {
    ^
matlab/src/vl_nnpool.cu:269:7: note: Found duplicate branches for 'if' and 'else'.
    } else {
      ^
matlab/src/vl_nnpool.cu:263:5: note: Found duplicate branches for 'if' and 'else'.
    if (data.getDeviceType() == vl::VLDT_GPU) {
    ^
matlab/src/vl_tmove.cpp:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 14 configurations. Use --force to check all configurations. [toomanyconfigs]

^
matlab/src/vl_tmove.cu:255:25: warning: Member variable 'SharedTensorDescriptor::deviceType' is not initialized in the constructor. [uninitMemberVar]
SharedTensorDescriptor::SharedTensorDescriptor()
                        ^
matlab/src/vl_tmove.cu:255:25: warning: Member variable 'SharedTensorDescriptor::dataType' is not initialized in the constructor. [uninitMemberVar]
SharedTensorDescriptor::SharedTensorDescriptor()
                        ^
matlab/src/vl_tmove.cu:406:20: warning: Member variable 'SharedTensorSpace::lab' is not initialized in the constructor. [uninitMemberVar]
SharedTensorSpace::SharedTensorSpace()
                   ^
matlab/src/vl_tmove.cu:406:20: warning: Member variable 'SharedTensorSpace::numLabs' is not initialized in the constructor. [uninitMemberVar]
SharedTensorSpace::SharedTensorSpace()
                   ^
matlab/src/vl_tmove.cu:406:20: warning: Member variable 'SharedTensorSpace::state' is not initialized in the constructor. [uninitMemberVar]
SharedTensorSpace::SharedTensorSpace()
                   ^
matlab/src/vl_tmove.cu:406:20: warning: Member variable 'SharedTensorSpace::memoryMapLabStride' is not initialized in the constructor. [uninitMemberVar]
SharedTensorSpace::SharedTensorSpace()
                   ^
matlab/src/vl_tmove.cu:352:5: warning: Member variable 'SharedTensorInstance::numChildrenToAccumulate' is not initialized in the constructor. [uninitMemberVar]
    SharedTensorInstance()
    ^
matlab/src/vl_tmove.cu:352:5: warning: Member variable 'SharedTensorInstance::memoryMapOffset' is not initialized in the constructor. [uninitMemberVar]
    SharedTensorInstance()
    ^
matlab/src/vl_tmove.cu:1007:14: warning: Member variable 'ProcessPool::timeoutInterval' is not initialized in the constructor. [uninitMemberVar]
ProcessPool::ProcessPool()
             ^
matlab/src/vl_tmove.cu:1007:14: warning: Member variable 'ProcessPool::sharedSpace' is not initialized in the constructor. [uninitMemberVar]
ProcessPool::ProcessPool()
             ^
matlab/src/vl_tmove.cu:939:5: warning: Member variable 'Message::type' is not initialized in the constructor. [uninitMemberVar]
    Message() : transaction(0), finalTransaction((size_t)-1), tensorId(0) { }
    ^
matlab/src/vl_tmove.cu:939:5: warning: Member variable 'Message::from' is not initialized in the constructor. [uninitMemberVar]
    Message() : transaction(0), finalTransaction((size_t)-1), tensorId(0) { }
    ^
matlab/src/vl_tmove.cu:939:5: warning: Member variable 'Message::to' is not initialized in the constructor. [uninitMemberVar]
    Message() : transaction(0), finalTransaction((size_t)-1), tensorId(0) { }
    ^
matlab/src/vl_tmove.cu:939:5: warning: Member variable 'Message::session' is not initialized in the constructor. [uninitMemberVar]
    Message() : transaction(0), finalTransaction((size_t)-1), tensorId(0) { }
    ^
matlab/src/vl_tmove.cu:939:5: warning: Member variable 'Message::tensorState' is not initialized in the constructor. [uninitMemberVar]
    Message() : transaction(0), finalTransaction((size_t)-1), tensorId(0) { }
    ^
matlab/src/vl_tmove.cu:944:5: warning: Member variable 'Supervisor::session' is not initialized in the constructor. [uninitMemberVar]
    Supervisor(ProcessPool& pool)
    ^
matlab/src/vl_tmove.cu:944:5: warning: Member variable 'Supervisor::shutdownRequested' is not initialized in the constructor. [uninitMemberVar]
    Supervisor(ProcessPool& pool)
    ^
matlab/src/vl_tmove.cu:944:5: warning: Member variable 'Supervisor::forceQuit' is not initialized in the constructor. [uninitMemberVar]
    Supervisor(ProcessPool& pool)
    ^
matlab/src/vl_tmove.cu:383:10: style:inconclusive: Member variable 'SharedTensorSpace::memoryMap' is in the wrong place in the initializer list. [initializerList]
  void * memoryMap ;
         ^
matlab/src/vl_tmove.cu:409:5: note: Member variable 'SharedTensorSpace::memoryMap' is in the wrong place in the initializer list.
    memoryMap(NULL),
    ^
matlab/src/vl_tmove.cu:383:10: note: Member variable 'SharedTensorSpace::memoryMap' is in the wrong place in the initializer list.
  void * memoryMap ;
         ^
matlab/src/vl_tmove.cu:384:10: style:inconclusive: Member variable 'SharedTensorSpace::memoryMapSize' is in the wrong place in the initializer list. [initializerList]
  size_t memoryMapSize ;
         ^
matlab/src/vl_tmove.cu:411:5: note: Member variable 'SharedTensorSpace::memoryMapSize' is in the wrong place in the initializer list.
    memoryMapSize(0),
    ^
matlab/src/vl_tmove.cu:384:10: note: Member variable 'SharedTensorSpace::memoryMapSize' is in the wrong place in the initializer list.
  size_t memoryMapSize ;
         ^
matlab/src/vl_tmove.cu:391:10: style:inconclusive: Member variable 'SharedTensorSpace::gpuDispatchMemory' is in the wrong place in the initializer list. [initializerList]
  void * gpuDispatchMemory ;
         ^
matlab/src/vl_tmove.cu:413:5: note: Member variable 'SharedTensorSpace::gpuDispatchMemory' is in the wrong place in the initializer list.
    gpuDispatchMemory(NULL)
    ^
matlab/src/vl_tmove.cu:391:10: note: Member variable 'SharedTensorSpace::gpuDispatchMemory' is in the wrong place in the initializer list.
  void * gpuDispatchMemory ;
         ^
matlab/src/vl_tmove.cu:368:12: style:inconclusive: Member variable 'SharedTensorPeerInstance::finalTransaction' is in the wrong place in the initializer list. [initializerList]
    size_t finalTransaction ;
           ^
matlab/src/vl_tmove.cu:376:9: note: Member variable 'SharedTensorPeerInstance::finalTransaction' is in the wrong place in the initializer list.
        finalTransaction((size_t)-1) { }
        ^
matlab/src/vl_tmove.cu:368:12: note: Member variable 'SharedTensorPeerInstance::finalTransaction' is in the wrong place in the initializer list.
    size_t finalTransaction ;
           ^
matlab/src/vl_tmove.cu:890:8: style:inconclusive: Member variable 'ProcessPool::initialized' is in the wrong place in the initializer list. [initializerList]
  bool initialized ;
       ^
matlab/src/vl_tmove.cu:1009:3: note: Member variable 'ProcessPool::initialized' is in the wrong place in the initializer list.
  initialized(false),
  ^
matlab/src/vl_tmove.cu:890:8: note: Member variable 'ProcessPool::initialized' is in the wrong place in the initializer list.
  bool initialized ;
       ^
matlab/src/vl_tmove.cu:245:8: performance:inconclusive: Technically the member function 'SharedTensorDescriptor::finalize' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  void finalize() ;
       ^
matlab/src/vl_tmove.cu:283:30: note: Technically the member function 'SharedTensorDescriptor::finalize' can be static (but you may consider moving to unnamed namespace).
void SharedTensorDescriptor::finalize()
                             ^
matlab/src/vl_tmove.cu:245:8: note: Technically the member function 'SharedTensorDescriptor::finalize' can be static (but you may consider moving to unnamed namespace).
  void finalize() ;
       ^
matlab/src/vl_tmove.cu:351:10: style:inconclusive: Technically the member function 'SharedTensorSpace::SharedTensorInstance::operator==' can be const. [functionConst]
    bool operator==(std::string const & theName) { return name == theName ; }
         ^
matlab/src/vl_tmove.cu:372:10: style:inconclusive: Technically the member function 'SharedTensorSpace::SharedTensorPeerInstance::operator==' can be const. [functionConst]
    bool operator==(int theLab) { return lab == theLab ; }
         ^
matlab/src/vl_tmove.cu:977:12: style:inconclusive: Technically the member function 'ProcessPool::Supervisor::Peer::operator==' can be const. [functionConst]
      bool operator== (int lab) { return this->lab == lab ; }
           ^
matlab/src/vl_tmove.cu:944:5: style: Class 'Supervisor' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Supervisor(ProcessPool& pool)
    ^
matlab/src/vl_tmove.cu:972:7: style: Struct 'Peer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
      Peer(int lab)
      ^
matlab/src/vl_tmove.cu:1776:13: style: Condition 'error==vl::VLE_Success' is always true [knownConditionTrueFalse]
  if (error == vl::VLE_Success) {
            ^
matlab/src/vl_tmove.cu:1757:27: note: Assignment 'error=vl::VLE_Success', assigned value is 0
  vl::ErrorCode error = vl::VLE_Success ;
                          ^
matlab/src/vl_tmove.cu:1776:13: note: Condition 'error==vl::VLE_Success' is always true
  if (error == vl::VLE_Success) {
            ^
matlab/src/vl_tmove.cu:1797:59: style: Condition 'error==vl::VLE_Success' is always true [knownConditionTrueFalse]
  for (int p = (pool.lab > 0) ; p < peers.size() && error == vl::VLE_Success ; ++p)
                                                          ^
matlab/src/vl_tmove.cu:1793:27: note: Assignment 'error=vl::VLE_Success', assigned value is 0
  vl::ErrorCode error = vl::VLE_Success ;
                          ^
matlab/src/vl_tmove.cu:1797:59: note: Condition 'error==vl::VLE_Success' is always true
  for (int p = (pool.lab > 0) ; p < peers.size() && error == vl::VLE_Success ; ++p)
                                                          ^
matlab/src/vl_tmove.cu:1922:13: style: Condition 'error!=vl::VLE_Success' is always false [knownConditionTrueFalse]
  if (error != vl::VLE_Success) { return error ; }
            ^
matlab/src/vl_tmove.cu:1793:27: note: Assignment 'error=vl::VLE_Success', assigned value is 0
  vl::ErrorCode error = vl::VLE_Success ;
                          ^
matlab/src/vl_tmove.cu:1922:13: note: Condition 'error!=vl::VLE_Success' is always false
  if (error != vl::VLE_Success) { return error ; }
            ^
matlab/src/vl_tmove.cu:1376:7: style: The scope of the variable 'status' can be reduced. [variableScope]
  int status ;
      ^
matlab/src/vl_tmove.cu:1400:10: style: The scope of the variable 'waited' can be reduced. [variableScope]
  size_t waited = 0 ; // us
         ^
matlab/src/vl_tmove.cu:1411:9: style: The scope of the variable 'status' can be reduced. [variableScope]
    int status ;
        ^
matlab/src/vl_tmove.cu:2126:7: style: The scope of the variable 'pollStatus' can be reduced. [variableScope]
  int pollStatus = 0 ;
      ^
matlab/src/vl_tmove.cu:272:50: style:inconclusive: Function 'init' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'. [funcArgNamesDifferent]
void SharedTensorDescriptor::init(vl::DeviceType newDeviceType,
                                                 ^
matlab/src/vl_tmove.cu:242:28: note: Function 'init' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'.
  void init(vl::DeviceType deviceType,
                           ^
matlab/src/vl_tmove.cu:272:50: note: Function 'init' argument 1 names different: declaration 'deviceType' definition 'newDeviceType'.
void SharedTensorDescriptor::init(vl::DeviceType newDeviceType,
                                                 ^
matlab/src/vl_tmove.cu:273:48: style:inconclusive: Function 'init' argument 2 names different: declaration 'dataType' definition 'newDataType'. [funcArgNamesDifferent]
                                  vl::DataType newDataType,
                                               ^
matlab/src/vl_tmove.cu:243:26: note: Function 'init' argument 2 names different: declaration 'dataType' definition 'newDataType'.
            vl::DataType dataType,
                         ^
matlab/src/vl_tmove.cu:273:48: note: Function 'init' argument 2 names different: declaration 'dataType' definition 'newDataType'.
                                  vl::DataType newDataType,
                                               ^
matlab/src/vl_tmove.cu:274:59: style:inconclusive: Function 'init' argument 3 names different: declaration 'shape' definition 'newShape'. [funcArgNamesDifferent]
                                  vl::TensorShape const & newShape)
                                                          ^
matlab/src/vl_tmove.cu:244:37: note: Function 'init' argument 3 names different: declaration 'shape' definition 'newShape'.
            vl::TensorShape const & shape) ;
                                    ^
matlab/src/vl_tmove.cu:274:59: note: Function 'init' argument 3 names different: declaration 'shape' definition 'newShape'.
                                  vl::TensorShape const & newShape)
                                                          ^
matlab/src/vl_tmove.cu:431:57: style:inconclusive: Function 'mexInit' argument 1 names different: declaration 'mexDescriptor' definition 'descriptor'. [funcArgNamesDifferent]
vl::ErrorCode SharedTensorSpace::mexInit(mxArray const *descriptor)
                                                        ^
matlab/src/vl_tmove.cu:313:40: note: Function 'mexInit' argument 1 names different: declaration 'mexDescriptor' definition 'descriptor'.
  vl::ErrorCode mexInit(mxArray const *mexDescriptor) ;
                                       ^
matlab/src/vl_tmove.cu:431:57: note: Function 'mexInit' argument 1 names different: declaration 'mexDescriptor' definition 'descriptor'.
vl::ErrorCode SharedTensorSpace::mexInit(mxArray const *descriptor)
                                                        ^
matlab/src/vl_tmove.cu:1018:53: style:inconclusive: Function 'init' argument 1 names different: declaration 'prefix' definition 'newPrefix'. [funcArgNamesDifferent]
vl::ErrorCode ProcessPool::init(std::string const & newPrefix, int newLab, int newNumLabs, SharedTensorSpace * newSharedSpace)
                                                    ^
matlab/src/vl_tmove.cu:852:42: note: Function 'init' argument 1 names different: declaration 'prefix' definition 'newPrefix'.
  vl::ErrorCode init(std::string const & prefix, int lab,
                                         ^
matlab/src/vl_tmove.cu:1018:53: note: Function 'init' argument 1 names different: declaration 'prefix' definition 'newPrefix'.
vl::ErrorCode ProcessPool::init(std::string const & newPrefix, int newLab, int newNumLabs, SharedTensorSpace * newSharedSpace)
                                                    ^
matlab/src/vl_tmove.cu:1018:68: style:inconclusive: Function 'init' argument 2 names different: declaration 'lab' definition 'newLab'. [funcArgNamesDifferent]
vl::ErrorCode ProcessPool::init(std::string const & newPrefix, int newLab, int newNumLabs, SharedTensorSpace * newSharedSpace)
                                                                   ^
matlab/src/vl_tmove.cu:852:54: note: Function 'init' argument 2 names different: declaration 'lab' definition 'newLab'.
  vl::ErrorCode init(std::string const & prefix, int lab,
                                                     ^
matlab/src/vl_tmove.cu:1018:68: note: Function 'init' argument 2 names different: declaration 'lab' definition 'newLab'.
vl::ErrorCode ProcessPool::init(std::string const & newPrefix, int newLab, int newNumLabs, SharedTensorSpace * newSharedSpace)
                                                                   ^
matlab/src/vl_tmove.cu:1018:80: style:inconclusive: Function 'init' argument 3 names different: declaration 'numLabs' definition 'newNumLabs'. [funcArgNamesDifferent]
vl::ErrorCode ProcessPool::init(std::string const & newPrefix, int newLab, int newNumLabs, SharedTensorSpace * newSharedSpace)
                                                                               ^
matlab/src/vl_tmove.cu:853:26: note: Function 'init' argument 3 names different: declaration 'numLabs' definition 'newNumLabs'.
                     int numLabs, SharedTensorSpace * space) ;
                         ^
matlab/src/vl_tmove.cu:1018:80: note: Function 'init' argument 3 names different: declaration 'numLabs' definition 'newNumLabs'.
vl::ErrorCode ProcessPool::init(std::string const & newPrefix, int newLab, int newNumLabs, SharedTensorSpace * newSharedSpace)
                                                                               ^
matlab/src/vl_tmove.cu:1018:112: style:inconclusive: Function 'init' argument 4 names different: declaration 'space' definition 'newSharedSpace'. [funcArgNamesDifferent]
vl::ErrorCode ProcessPool::init(std::string const & newPrefix, int newLab, int newNumLabs, SharedTensorSpace * newSharedSpace)
                                                                                                               ^
matlab/src/vl_tmove.cu:853:55: note: Function 'init' argument 4 names different: declaration 'space' definition 'newSharedSpace'.
                     int numLabs, SharedTensorSpace * space) ;
                                                      ^
matlab/src/vl_tmove.cu:1018:112: note: Function 'init' argument 4 names different: declaration 'space' definition 'newSharedSpace'.
vl::ErrorCode ProcessPool::init(std::string const & newPrefix, int newLab, int newNumLabs, SharedTensorSpace * newSharedSpace)
                                                                                                               ^
matlab/src/vl_tmove.cu:1609:11: style: Local variable 'result' shadows outer variable [shadowVariable]
      int result = ::connect(peers[0].socketFD,
          ^
matlab/src/vl_tmove.cu:1474:7: note: Shadowed declaration
  int result ;
      ^
matlab/src/vl_tmove.cu:1609:11: note: Shadow variable
      int result = ::connect(peers[0].socketFD,
          ^
matlab/src/vl_tmove.cu:2426:19: style: Local variable 'error' shadows outer variable [shadowVariable]
    VLMXErrorCode error = vlmxParseString(tensorName, in[1]) ;
                  ^
matlab/src/vl_tmove.cu:2374:17: note: Shadowed declaration
  vl::ErrorCode error = vl::VLE_Success ;
                ^
matlab/src/vl_tmove.cu:2426:19: note: Shadow variable
    VLMXErrorCode error = vlmxParseString(tensorName, in[1]) ;
                  ^
matlab/src/vl_tmove.cu:2437:19: style: Local variable 'error' shadows outer variable [shadowVariable]
    VLMXErrorCode error = vlmxParseString(tensorName, in[1]) ;
                  ^
matlab/src/vl_tmove.cu:2374:17: note: Shadowed declaration
  vl::ErrorCode error = vl::VLE_Success ;
                ^
matlab/src/vl_tmove.cu:2437:19: note: Shadow variable
    VLMXErrorCode error = vlmxParseString(tensorName, in[1]) ;
                  ^
matlab/src/vl_tmove.cu:2474:24: warning:inconclusive: Found suspicious operator '&&' [constStatement]
      (verbosity >= 2) && mexPrintf("vl_tmove: command 'init'\n") ;
                       ^
matlab/src/vl_tmove.cu:2494:24: warning:inconclusive: Found suspicious operator '&&' [constStatement]
      (verbosity >= 2) && mexPrintf("vl_tmove: command 'stats'\n") ;
                       ^
matlab/src/vl_tmove.cu:2499:24: warning:inconclusive: Found suspicious operator '&&' [constStatement]
      (verbosity >= 2) && mexPrintf("vl_tmove: command 'push' on tensor '%s'%s\n", tensorName.c_str(), inplace?" (inplace)":"") ;
                       ^
matlab/src/vl_tmove.cu:2504:24: warning:inconclusive: Found suspicious operator '&&' [constStatement]
      (verbosity >= 2) && mexPrintf("vl_tmove: command 'pull' on tensor '%s'%s\n", tensorName.c_str(),
                       ^
matlab/src/vl_tmove.cu:2510:24: warning:inconclusive: Found suspicious operator '&&' [constStatement]
      (verbosity >= 2) && mexPrintf("vl_tmove: command 'reset'\n") ;
                       ^
matlab/src/vl_tmove.cu:1348:45: style: Variable 'T' can be declared with const [constVariable]
  SharedTensorSpace::SharedTensorInstance & T = pool.sharedSpace->tensors[tensorIndex] ;
                                            ^
matlab/src/vl_tmove.cu:1086:32: warning: Either the condition 'T==sharedSpace->tensors.end()' is redundant or there is possible dereference of an invalid iterator: T. [derefInvalidIteratorRedundantCheck]
  if (mtens.getDeviceType() != T->descriptor.deviceType) {
                               ^
matlab/src/vl_tmove.cu:1078:9: note: Assuming that condition 'T==sharedSpace->tensors.end()' is not redundant
  if (T == sharedSpace->tensors.end()) {
        ^
matlab/src/vl_tmove.cu:1086:32: note: Dereference of an invalid iterator
  if (mtens.getDeviceType() != T->descriptor.deviceType) {
                               ^
matlab/src/vl_tmove.cu:1090:30: warning: Either the condition 'T==sharedSpace->tensors.end()' is redundant or there is possible dereference of an invalid iterator: T. [derefInvalidIteratorRedundantCheck]
  if (mtens.getDataType() != T->descriptor.dataType) {
                             ^
matlab/src/vl_tmove.cu:1078:9: note: Assuming that condition 'T==sharedSpace->tensors.end()' is not redundant
  if (T == sharedSpace->tensors.end()) {
        ^
matlab/src/vl_tmove.cu:1090:30: note: Dereference of an invalid iterator
  if (mtens.getDataType() != T->descriptor.dataType) {
                             ^
matlab/src/vl_tmove.cu:1094:33: warning: Either the condition 'T==sharedSpace->tensors.end()' is redundant or there is possible dereference of an invalid iterator: T. [derefInvalidIteratorRedundantCheck]
  if (mtens.getNumElements() != T->descriptor.shape.getNumElements()) {
                                ^
matlab/src/vl_tmove.cu:1078:9: note: Assuming that condition 'T==sharedSpace->tensors.end()' is not redundant
  if (T == sharedSpace->tensors.end()) {
        ^
matlab/src/vl_tmove.cu:1094:33: note: Dereference of an invalid iterator
  if (mtens.getNumElements() != T->descriptor.shape.getNumElements()) {
                                ^
matlab/src/vl_tmove.cu:1242:32: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
  int parent = pool.lab & (~(1 << bit)) ;
                               ^
matlab/src/vl_tmove.cu:1240:26: note: Assignment 'bit=31', assigned value is 31
  if (bit == -1) { bit = 31 ; }
                         ^
matlab/src/vl_tmove.cu:1242:32: note: Shift
  int parent = pool.lab & (~(1 << bit)) ;
                               ^
matlab/src/vl_tmove.cu:1242:32: error: Signed integer overflow for expression '1<<bit'. [integerOverflow]
  int parent = pool.lab & (~(1 << bit)) ;
                               ^
matlab/src/vl_tmove.cu:1240:26: note: Assignment 'bit=31', assigned value is 31
  if (bit == -1) { bit = 31 ; }
                         ^
matlab/src/vl_tmove.cu:1242:32: note: Integer overflow
  int parent = pool.lab & (~(1 << bit)) ;
                               ^
matlab/src/vl_tmove.cu:460:15: style: Variable 'useGPU' is assigned a value that is never used. [unreadVariable]
  bool useGPU = false ;
              ^
matlab/src/vl_tmove.cu:495:14: style: Variable 'useGPU' is assigned a value that is never used. [unreadVariable]
      useGPU = true ;
             ^
matlab/src/vl_tmove.cu:1785:11: style: Variable 'error' is assigned a value that is never used. [unreadVariable]
    error = loop() ;
          ^
matlab/src/vl_tmove.cu:2126:18: style: Variable 'pollStatus' is assigned a value that is never used. [unreadVariable]
  int pollStatus = 0 ;
                 ^
vlfeat/src/aib.c:31:13: style: The scope of the variable 'aib' can be reduced. [variableScope]
    VlAIB * aib;
            ^
vlfeat/src/aib.c:32:15: style: The scope of the variable 'parents' can be reduced. [variableScope]
    vl_uint * parents;
              ^
vlfeat/src/sift.c:564:11: error: Common realloc mistake: 'ikeys' nulled but not freed upon failure [memleakOnRealloc]
          ikeys       = realloc (ikeys, 4 * sizeof(double) * ikeys_size) ;
          ^
vlfeat/src/sift.c:506:10: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
    err  = vl_pgm_extract_data (in, &pim, data) ;
         ^
vlfeat/src/sift.c:476:13: note: err is assigned
        err = VL_ERR_IO ;
            ^
vlfeat/src/sift.c:506:10: note: err is overwritten
    err  = vl_pgm_extract_data (in, &pim, data) ;
         ^
vlfeat/src/test_gmm.c:270:30: portability: Casting between const double * and float * which have an incompatible binary data representation. [invalidPointerCast]
        fprintf(ofp, "%f ", ((float*)means)[cIdx*dimension+d]);
                             ^
vlfeat/src/test_gmm.c:273:30: portability: Casting between const double * and float * which have an incompatible binary data representation. [invalidPointerCast]
        fprintf(ofp, "%f ", ((float*)sigmas)[cIdx*dimension+d]);
                             ^
vlfeat/src/test_gmm.c:275:28: portability: Casting between const double * and float * which have an incompatible binary data representation. [invalidPointerCast]
      fprintf(ofp, "%f ", ((float*)weights)[cIdx]);
                           ^
vlfeat/src/test_gmm.c:277:30: portability: Casting between const double * and float * which have an incompatible binary data representation. [invalidPointerCast]
        fprintf(ofp, "%f ", ((float*)posteriors)[cIdx*numData + i_d]);
                             ^
vlfeat/src/test_mathop_fast_sqrt_ui.tc:20:36: error: There is an unknown macro here somewhere. Configuration is required. If VL_XCAT is a macro then please configure it. [unknownMacro]
  VL_PRINTF (" %10.2f %10.2g %010" FL "x\n", elaps, (double) neval / elaps, acc) ;
                                   ^
vlfeat/toolbox/aib/vl_aib.c:110:29: style:inconclusive: Boolean expression 'parents[n]<=e' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
      if ((parents[n] <= e) & (parents[n] != 1)) {
                            ^
vlfeat/toolbox/aib/vl_aib.c:126:28: style:inconclusive: Boolean expression 'parents[n]<=e' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
    if ((parents [n] <= e) & (parents [n] != 0)) {
                           ^
vlfeat/toolbox/aib/vl_aibhist.c:106:23: style:inconclusive: Boolean expression 'node!=0' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
      if ((node != 0) & (node != 1)) {
                      ^
vlfeat/toolbox/aib/vl_aibhist.c:119:23: style:inconclusive: Boolean expression 'node!=0' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
      if ((node != 0) & (node != 1) & (node < i)) {
                      ^
vlfeat/toolbox/aib/vl_aibhist.c:119:37: style:inconclusive: Boolean expression 'node<i' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
      if ((node != 0) & (node != 1) & (node < i)) {
                                    ^
vlfeat/toolbox/aib/vl_aibhist.c:147:19: style:inconclusive: Boolean expression 'x<1' is used in bitwise operation. Did you mean '||'? [bitwiseOnBoolean]
      if ((x < 1) | (x > last_leaf)) {
                  ^
vlfeat/toolbox/aib/vl_aibhist.c:162:23: style:inconclusive: Boolean expression 'x_==x' is used in bitwise operation. Did you mean '||'? [bitwiseOnBoolean]
        if ((x_ == x) | (x_ == 0) | (x_ == 1)) break ;
                      ^
vlfeat/toolbox/aib/vl_aibhist.c:162:35: style:inconclusive: Boolean expression 'x_==1' is used in bitwise operation. Did you mean '||'? [bitwiseOnBoolean]
        if ((x_ == x) | (x_ == 0) | (x_ == 1)) break ;
                                  ^
vlfeat/toolbox/aib/vl_aibhist.c:39:7: style: The scope of the variable 'nnull' can be reduced. [variableScope]
  int nnull = 0 ;
      ^
vlfeat/toolbox/imop/vl_imsmooth.c:29:1: error: There is an unknown macro here somewhere. Configuration is required. If VL_XCAT is a macro then please configure it. [unknownMacro]
VL_XCAT(_vl_imsmooth_smooth_, SFX)
^
vlfeat/toolbox/imop/vl_imwbackwardmx.c:37:7: style: The scope of the variable 'pivot' can be reduced. [variableScope]
  int pivot = 0 ;
      ^
vlfeat/toolbox/imop/vl_imwbackwardmx.c:38:10: style: The scope of the variable 'y' can be reduced. [variableScope]
  double y = 0 ;
         ^
vlfeat/toolbox/imop/vl_imwbackwardmx.c:37:13: style: Variable 'pivot' is assigned a value that is never used. [unreadVariable]
  int pivot = 0 ;
            ^
vlfeat/toolbox/imop/vl_imwbackwardmx.c:38:12: style: Variable 'y' is assigned a value that is never used. [unreadVariable]
  double y = 0 ;
           ^
vlfeat/toolbox/kmeans/vl_hikmeans.c:112:7: style: The scope of the variable 'max_niters' can be reduced. [variableScope]
  int max_niters = 200 ;
      ^
vlfeat/toolbox/misc/vl_binsum.def:77:1: error: There is an unknown macro here somewhere. Configuration is required. If VL_XCAT4 is a macro then please configure it. [unknownMacro]
VL_XCAT4(_vl_binsum_,__VALUE_T__,_,__INDEX_T__)
^
vlfeat/toolbox/misc/vl_cummax.def:68:1: error: There is an unknown macro here somewhere. Configuration is required. If VL_XCAT is a macro then please configure it. [unknownMacro]
VL_XCAT(_vl_cummax_,__VALUE_T__)
^
vlfeat/toolbox/misc/vl_hog.c:50:19: style: The scope of the variable 'descriptor_array' can be reduced. [variableScope]
  mxArray const * descriptor_array ;
                  ^
vlfeat/toolbox/misc/vl_inthist.c:99:12: style: Variable 'labelsPt' is reassigned a value before the old one has been used. [redundantAssignment]
  labelsPt = mxGetData(IN(LABELS)) ;
           ^
vlfeat/toolbox/misc/vl_inthist.c:92:12: note: labelsPt is assigned
  labelsPt = mxGetData(IN(LABELS)) ;
           ^
vlfeat/toolbox/misc/vl_inthist.c:99:12: note: labelsPt is overwritten
  labelsPt = mxGetData(IN(LABELS)) ;
           ^
vlfeat/toolbox/misc/kdtree.h:199:19: style: The scope of the variable 'nodes_array' can be reduced. [variableScope]
  mxArray const * nodes_array ;
                  ^
vlfeat/toolbox/misc/kdtree.h:200:19: style: The scope of the variable 'dataIndex_array' can be reduced. [variableScope]
  mxArray const * dataIndex_array ;
                  ^
vlfeat/toolbox/misc/kdtree.h:201:19: style: The scope of the variable 'lowerChild_array' can be reduced. [variableScope]
  mxArray const * lowerChild_array ;
                  ^
vlfeat/toolbox/misc/kdtree.h:202:19: style: The scope of the variable 'upperChild_array' can be reduced. [variableScope]
  mxArray const * upperChild_array ;
                  ^
vlfeat/toolbox/misc/kdtree.h:203:19: style: The scope of the variable 'splitDimension_array' can be reduced. [variableScope]
  mxArray const * splitDimension_array ;
                  ^
vlfeat/toolbox/misc/kdtree.h:204:19: style: The scope of the variable 'splitThreshold_array' can be reduced. [variableScope]
  mxArray const * splitThreshold_array ;
                  ^
vlfeat/toolbox/misc/kdtree.h:205:19: style: The scope of the variable 'lowerBound_array' can be reduced. [variableScope]
  mxArray const * lowerBound_array;
                  ^
vlfeat/toolbox/misc/kdtree.h:206:19: style: The scope of the variable 'upperBound_array' can be reduced. [variableScope]
  mxArray const * upperBound_array;
                  ^
vlfeat/toolbox/misc/vl_svmtrain.c:149:12: style: The scope of the variable 'gamma' can be reduced. [variableScope]
    double gamma = 1.0 ;
           ^
vlfeat/toolbox/misc/vl_svmtrain.c:150:12: style: The scope of the variable 'period' can be reduced. [variableScope]
    double period = -1 ;
           ^
vlfeat/toolbox/misc/vl_svmtrain.c:151:9: style: The scope of the variable 'n' can be reduced. [variableScope]
    int n = 1 ;
        ^
vlfeat/toolbox/misc/vl_svmtrain.c:154:15: style: The scope of the variable 'field' can be reduced. [variableScope]
    mxArray * field ;
              ^
vlfeat/toolbox/mser/vl_erfill.c:192:12: style: Local variable 'dims' shadows outer variable [shadowVariable]
    mwSize dims[2] ;
           ^
vlfeat/toolbox/mser/vl_erfill.c:55:18: note: Shadowed declaration
  mwSize const * dims ;
                 ^
vlfeat/toolbox/mser/vl_erfill.c:192:12: note: Shadow variable
    mwSize dims[2] ;
           ^
vlfeat/toolbox/mser/vl_mser.c:80:25: style: The scope of the variable 'j' can be reduced. [variableScope]
  int                i, j, dof = 0 ;
                        ^
vlfeat/toolbox/sift/vl_covdet.c:222:10: style: The scope of the variable 'boundaryMargin' can be reduced. [variableScope]
  double boundaryMargin = 2.0 ;
         ^
vlfeat/toolbox/sift/vl_dsift.c:206:9: style: The scope of the variable 'k' can be reduced. [variableScope]
    int k, i ;
        ^
vlfeat/toolbox/sift/vl_dsift.c:206:12: style: The scope of the variable 'i' can be reduced. [variableScope]
    int k, i ;
           ^
vlfeat/toolbox/sift/vl_dsift.c:239:15: style: Local variable 'useFlatWindow' shadows outer variable [shadowVariable]
      vl_bool useFlatWindow ;
              ^
vlfeat/toolbox/sift/vl_dsift.c:72:11: note: Shadowed declaration
  vl_bool useFlatWindow = VL_FALSE ;
          ^
vlfeat/toolbox/sift/vl_dsift.c:239:15: note: Shadow variable
      vl_bool useFlatWindow ;
              ^
vlfeat/toolbox/sift/vl_siftdescriptor.c:97:9: style: The scope of the variable 'j' can be reduced. [variableScope]
  int i,j ;
        ^
vlfeat/toolbox/sift/vl_siftdescriptor.c:218:17: style: Local variable 'x' shadows outer variable [shadowVariable]
          float x = 512.0F * rbuf [j] ;
                ^
vlfeat/toolbox/sift/vl_siftdescriptor.c:203:14: note: Shadowed declaration
      double x  = *ikeys++ - 1 ;
             ^
vlfeat/toolbox/sift/vl_siftdescriptor.c:218:17: note: Shadow variable
          float x = 512.0F * rbuf [j] ;
                ^
vlfeat/vl/aib.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/aib.c:590:30: style: The scope of the variable 'newnode' can be reduced. [variableScope]
    vl_uint i, besti, bestj, newnode, nodei, nodej;
                             ^
vlfeat/vl/aib.c:590:39: style: The scope of the variable 'nodei' can be reduced. [variableScope]
    vl_uint i, besti, bestj, newnode, nodei, nodej;
                                      ^
vlfeat/vl/aib.c:590:46: style: The scope of the variable 'nodej' can be reduced. [variableScope]
    vl_uint i, besti, bestj, newnode, nodei, nodej;
                                             ^
vlfeat/vl/mathop.h:598:1: style: Variable 'tmp' is assigned a value that is never used. [unreadVariable]
VL_FAST_SQRT_UI(vl_uint64,ui64)
^
vlfeat/vl/mathop.h:599:1: style: Variable 'tmp' is assigned a value that is never used. [unreadVariable]
VL_FAST_SQRT_UI(vl_uint32,ui32)
^
vlfeat/vl/mathop.h:600:1: style: Variable 'tmp' is assigned a value that is never used. [unreadVariable]
VL_FAST_SQRT_UI(vl_uint16,ui16)
^
vlfeat/vl/mathop.h:601:1: style: Variable 'tmp' is assigned a value that is never used. [unreadVariable]
VL_FAST_SQRT_UI(vl_uint8,ui8)
^
vlfeat/vl/array.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/array.c:52:24: style:inconclusive: Function 'vl_array_init' argument 3 names different: declaration 'numDimension' definition 'numDimensions'. [funcArgNamesDifferent]
               vl_size numDimensions, vl_size const * dimensions)
                       ^
vlfeat/vl/array.h:90:74: note: Function 'vl_array_init' argument 3 names different: declaration 'numDimension' definition 'numDimensions'.
VL_EXPORT VlArray * vl_array_init (VlArray * self, vl_type type, vl_size numDimension, vl_size const * dimensions) ;
                                                                         ^
vlfeat/vl/array.c:52:24: note: Function 'vl_array_init' argument 3 names different: declaration 'numDimension' definition 'numDimensions'.
               vl_size numDimensions, vl_size const * dimensions)
                       ^
vlfeat/vl/array.c:77:33: style:inconclusive: Function 'vl_array_init_envelope' argument 4 names different: declaration 'numDimension' definition 'numDimensions'. [funcArgNamesDifferent]
                        vl_size numDimensions, vl_size const * dimensions)
                                ^
vlfeat/vl/array.h:91:95: note: Function 'vl_array_init_envelope' argument 4 names different: declaration 'numDimension' definition 'numDimensions'.
VL_EXPORT VlArray * vl_array_init_envelope (VlArray *self, void * data, vl_type type, vl_size numDimension, vl_size const * dimensions) ;
                                                                                              ^
vlfeat/vl/array.c:77:33: note: Function 'vl_array_init_envelope' argument 4 names different: declaration 'numDimension' definition 'numDimensions'.
                        vl_size numDimensions, vl_size const * dimensions)
                                ^
vlfeat/vl/array.c:149:37: style:inconclusive: Function 'vl_array_new' argument 2 names different: declaration 'numDimension' definition 'numDimensions'. [funcArgNamesDifferent]
vl_array_new (vl_type type, vl_size numDimensions, vl_size const * dimensions)
                                    ^
vlfeat/vl/array.h:95:57: note: Function 'vl_array_new' argument 2 names different: declaration 'numDimension' definition 'numDimensions'.
VL_EXPORT VlArray * vl_array_new (vl_type type, vl_size numDimension, vl_size const * dimensions) ;
                                                        ^
vlfeat/vl/array.c:149:37: note: Function 'vl_array_new' argument 2 names different: declaration 'numDimension' definition 'numDimensions'.
vl_array_new (vl_type type, vl_size numDimensions, vl_size const * dimensions)
                                    ^
vlfeat/vl/array.c:177:32: style:inconclusive: Function 'vl_array_new_envelope' argument 3 names different: declaration 'numDimension' definition 'numDimensions'. [funcArgNamesDifferent]
                       vl_size numDimensions, vl_size const * dimensions)
                               ^
vlfeat/vl/array.h:96:79: note: Function 'vl_array_new_envelope' argument 3 names different: declaration 'numDimension' definition 'numDimensions'.
VL_EXPORT VlArray * vl_array_new_envelope (void * data, vl_type type, vl_size numDimension, vl_size const * dimensions) ;
                                                                              ^
vlfeat/vl/array.c:177:32: note: Function 'vl_array_new_envelope' argument 3 names different: declaration 'numDimension' definition 'numDimensions'.
                       vl_size numDimensions, vl_size const * dimensions)
                               ^
vlfeat/vl/covdet.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/covdet.c:1071:0: error: failed to expand 'CHECK_NEIGHBORS_3', Invalid ## usage when expanding 'CHECK_NEIGHBORS_3'. [preprocessorErrorDirective]
#define CHECK_NEIGHBORS_3(v,CMP,SGN)     (\
^
vlfeat/vl/covdet.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. Use -v for more details. [noValidConfiguration]

^
vlfeat/vl/dsift.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/dsift.c:503:17: style: The scope of the variable 'yker' can be reduced. [variableScope]
  float *xker, *yker ;
                ^
vlfeat/vl/dsift.c:415:19: style:inconclusive: Function 'vl_dsift_new' argument 1 names different: declaration 'width' definition 'imWidth'. [funcArgNamesDifferent]
vl_dsift_new (int imWidth, int imHeight)
                  ^
vlfeat/vl/dsift.h:73:44: note: Function 'vl_dsift_new' argument 1 names different: declaration 'width' definition 'imWidth'.
VL_EXPORT VlDsiftFilter *vl_dsift_new (int width, int height) ;
                                           ^
vlfeat/vl/dsift.c:415:19: note: Function 'vl_dsift_new' argument 1 names different: declaration 'width' definition 'imWidth'.
vl_dsift_new (int imWidth, int imHeight)
                  ^
vlfeat/vl/dsift.c:415:32: style:inconclusive: Function 'vl_dsift_new' argument 2 names different: declaration 'height' definition 'imHeight'. [funcArgNamesDifferent]
vl_dsift_new (int imWidth, int imHeight)
                               ^
vlfeat/vl/dsift.h:73:55: note: Function 'vl_dsift_new' argument 2 names different: declaration 'height' definition 'imHeight'.
VL_EXPORT VlDsiftFilter *vl_dsift_new (int width, int height) ;
                                                      ^
vlfeat/vl/dsift.c:415:32: note: Function 'vl_dsift_new' argument 2 names different: declaration 'height' definition 'imHeight'.
vl_dsift_new (int imWidth, int imHeight)
                               ^
vlfeat/vl/dsift.c:467:25: style:inconclusive: Function 'vl_dsift_new_basic' argument 1 names different: declaration 'width' definition 'imWidth'. [funcArgNamesDifferent]
vl_dsift_new_basic (int imWidth, int imHeight, int step, int binSize)
                        ^
vlfeat/vl/dsift.h:74:50: note: Function 'vl_dsift_new_basic' argument 1 names different: declaration 'width' definition 'imWidth'.
VL_EXPORT VlDsiftFilter *vl_dsift_new_basic (int width, int height, int step, int binSize) ;
                                                 ^
vlfeat/vl/dsift.c:467:25: note: Function 'vl_dsift_new_basic' argument 1 names different: declaration 'width' definition 'imWidth'.
vl_dsift_new_basic (int imWidth, int imHeight, int step, int binSize)
                        ^
vlfeat/vl/dsift.c:467:38: style:inconclusive: Function 'vl_dsift_new_basic' argument 2 names different: declaration 'height' definition 'imHeight'. [funcArgNamesDifferent]
vl_dsift_new_basic (int imWidth, int imHeight, int step, int binSize)
                                     ^
vlfeat/vl/dsift.h:74:61: note: Function 'vl_dsift_new_basic' argument 2 names different: declaration 'height' definition 'imHeight'.
VL_EXPORT VlDsiftFilter *vl_dsift_new_basic (int width, int height, int step, int binSize) ;
                                                            ^
vlfeat/vl/dsift.c:467:38: note: Function 'vl_dsift_new_basic' argument 2 names different: declaration 'height' definition 'imHeight'.
vl_dsift_new_basic (int imWidth, int imHeight, int step, int binSize)
                                     ^
vlfeat/vl/fisher.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/fisher.c:423:10: style: The scope of the variable 'uprefix' can be reduced. [variableScope]
    TYPE uprefix;
         ^
vlfeat/vl/fisher.c:424:10: style: The scope of the variable 'vprefix' can be reduced. [variableScope]
    TYPE vprefix;
         ^
vlfeat/vl/generic.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 35 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/generic.c:903:23: warning: Either the condition 'string==0' is redundant or there is possible null pointer dereference: string. [nullPointerRedundantCheck]
    length = snprintf(string, length,
                      ^
vlfeat/vl/generic.c:898:17: note: Assuming that condition 'string==0' is not redundant
  while (string == 0) {
                ^
vlfeat/vl/generic.c:903:23: note: Null pointer dereference
    length = snprintf(string, length,
                      ^
vlfeat/vl/generic.c:1217:40: style:inconclusive: Function 'vl_set_num_threads' argument 1 names different: declaration 'n' definition 'VL_UNUSED'. [funcArgNamesDifferent]
vl_set_num_threads (vl_size numThreads VL_UNUSED) { }
                                       ^
vlfeat/vl/generic.h:115:44: note: Function 'vl_set_num_threads' argument 1 names different: declaration 'n' definition 'VL_UNUSED'.
VL_EXPORT void vl_set_num_threads (vl_size n) ;
                                           ^
vlfeat/vl/generic.c:1217:40: note: Function 'vl_set_num_threads' argument 1 names different: declaration 'n' definition 'VL_UNUSED'.
vl_set_num_threads (vl_size numThreads VL_UNUSED) { }
                                       ^
vlfeat/vl/generic.c:1034:9: error: Uninitialized variable: threadState [uninitvar]
  if (! threadState) {
        ^
vlfeat/vl/generic.c:1045:10: error: Uninitialized variable: threadState [uninitvar]
  return threadState ;
         ^
vlfeat/vl/generic.c:1034:7: note: Assuming condition is false
  if (! threadState) {
      ^
vlfeat/vl/generic.c:1045:10: note: Uninitialized variable: threadState
  return threadState ;
         ^
vlfeat/vl/generic.c:1026:9: style: Variable 'state' is assigned a value that is never used. [unreadVariable]
  state = vl_get_state() ;
        ^
vlfeat/vl/generic.c:1648:9: style: Variable 'state' is assigned a value that is never used. [unreadVariable]
  state = vl_get_state() ;
        ^
vlfeat/vl/generic.c:1529:13: style: Unused variable: state [unusedVariable]
  VlState * state ;
            ^
vlfeat/vl/generic.c:1530:19: style: Unused variable: threadState [unusedVariable]
  VlThreadState * threadState ;
                  ^
vlfeat/vl/generic.c:1217:29: style:inconclusive: Function 'vl_set_num_threads' argument 1 names different: declaration 'n' definition 'numThreads'. [funcArgNamesDifferent]
vl_set_num_threads (vl_size numThreads VL_UNUSED) { }
                            ^
vlfeat/vl/generic.h:115:44: note: Function 'vl_set_num_threads' argument 1 names different: declaration 'n' definition 'numThreads'.
VL_EXPORT void vl_set_num_threads (vl_size n) ;
                                           ^
vlfeat/vl/generic.c:1217:29: note: Function 'vl_set_num_threads' argument 1 names different: declaration 'n' definition 'numThreads'.
vl_set_num_threads (vl_size numThreads VL_UNUSED) { }
                            ^
vlfeat/vl/getopt_long.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/getopt_long.c:149:25: style: Redundant condition: If 'EXPR == '-'', the comparison 'EXPR' is always true. [redundantCondition]
    if (place[0]        &&
                        ^
vlfeat/vl/getopt_long.c:163:25: style: Redundant condition: If 'EXPR == '-'', the comparison 'EXPR' is always true. [redundantCondition]
    if (place[0]        &&
                        ^
vlfeat/vl/gmm.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 28 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/gmm.c:1295:27: style:inconclusive: Boolean expression 'restarted>0' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
      if ((restarted > 0) & (self->verbosity > 0)) {
                          ^
vlfeat/vl/gmm.c:1481:32: style:inconclusive: Function 'vl_gmm_new_copy' argument 1 names different: declaration 'gmm' definition 'self'. [funcArgNamesDifferent]
vl_gmm_new_copy (VlGMM const * self)
                               ^
vlfeat/vl/gmm.h:41:50: note: Function 'vl_gmm_new_copy' argument 1 names different: declaration 'gmm' definition 'self'.
VL_EXPORT VlGMM * vl_gmm_new_copy (VlGMM const * gmm) ;
                                                 ^
vlfeat/vl/gmm.c:1481:32: note: Function 'vl_gmm_new_copy' argument 1 names different: declaration 'gmm' definition 'self'.
vl_gmm_new_copy (VlGMM const * self)
                               ^
vlfeat/vl/hikmeans.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/hikmeans.c:163:15: style: The scope of the variable 'k' can be reduced. [variableScope]
    vl_uindex k ;
              ^
vlfeat/vl/hikmeans.c:259:16: style: The scope of the variable 'd' can be reduced. [variableScope]
  vl_uindex i, d ;
               ^
vlfeat/vl/hog.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/hog.c:288:19: style: The scope of the variable 'j' can be reduced. [variableScope]
      vl_index i, j ;
                  ^
vlfeat/vl/hog.c:302:16: style: The scope of the variable 'i' can be reduced. [variableScope]
      vl_index i, j ;
               ^
vlfeat/vl/hog.c:623:16: style: The scope of the variable 'orientation' can be reduced. [variableScope]
      vl_index orientation = 0 ;
               ^
vlfeat/vl/hog.c:772:16: style: The scope of the variable 'orientation' can be reduced. [variableScope]
      vl_index orientation = 0 ;
               ^
vlfeat/vl/hog.c:430:30: style:inconclusive: Function 'vl_hog_render' argument 3 names different: declaration 'features' definition 'descriptor'. [funcArgNamesDifferent]
               float const * descriptor,
                             ^
vlfeat/vl/hog.h:77:45: note: Function 'vl_hog_render' argument 3 names different: declaration 'features' definition 'descriptor'.
                              float const * features,
                                            ^
vlfeat/vl/hog.c:430:30: note: Function 'vl_hog_render' argument 3 names different: declaration 'features' definition 'descriptor'.
               float const * descriptor,
                             ^
vlfeat/vl/homkermap.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/homkermap.c:406:14: style: The scope of the variable 'x' can be reduced. [variableScope]
      double x, Lxgamma, Llogx, xgamma ;
             ^
vlfeat/vl/homkermap.c:406:17: style: The scope of the variable 'Lxgamma' can be reduced. [variableScope]
      double x, Lxgamma, Llogx, xgamma ;
                ^
vlfeat/vl/homkermap.c:406:26: style: The scope of the variable 'Llogx' can be reduced. [variableScope]
      double x, Lxgamma, Llogx, xgamma ;
                         ^
vlfeat/vl/homkermap.c:406:33: style: The scope of the variable 'xgamma' can be reduced. [variableScope]
      double x, Lxgamma, Llogx, xgamma ;
                                ^
vlfeat/vl/homkermap.c:560:12: style: The scope of the variable 'f1' can be reduced. [variableScope]
    double f1, f2 ;
           ^
vlfeat/vl/homkermap.c:560:16: style: The scope of the variable 'f2' can be reduced. [variableScope]
    double f1, f2 ;
               ^
vlfeat/vl/host.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 38 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/host.c:545:1: warning: snprintf format string requires 0 parameters but 1 is given. [wrongPrintfScanfArgNum]
snprintf(compilerString, 1024,
^
vlfeat/vl/host.c:477:23: warning: Either the condition 'string==0' is redundant or there is possible null pointer dereference: string. [nullPointerRedundantCheck]
    length = snprintf(string, length, "%s%s%s%s%s%s%s%s",
                      ^
vlfeat/vl/host.c:472:17: note: Assuming that condition 'string==0' is not redundant
  while (string == 0) {
                ^
vlfeat/vl/host.c:477:23: note: Null pointer dereference
    length = snprintf(string, length, "%s%s%s%s%s%s%s%s",
                      ^
vlfeat/vl/host.c:574:25: warning: Either the condition 'string==0' is redundant or there is possible null pointer dereference: string. [nullPointerRedundantCheck]
      length = snprintf(string, length, "%s, %s, %s",
                        ^
vlfeat/vl/host.c:569:19: note: Assuming that condition 'string==0' is not redundant
    while (string == 0) {
                  ^
vlfeat/vl/host.c:574:25: note: Null pointer dereference
      length = snprintf(string, length, "%s, %s, %s",
                        ^
vlfeat/vl/host.c:564:0: information: Skipping configuration 'VL_ARCH_IX86;__PIC__;__pic__;VL_COMPILER_GNUC' since the value of 'VL_COMPILER_GNUC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
           , v) ;
^
vlfeat/vl/host.c:545:1: error: snprintf format string requires 2 parameters but only 1 is given. [wrongPrintfScanfArgNum]
snprintf(compilerString, 1024,
^
vlfeat/vl/host.c:564:0: information: Skipping configuration 'VL_COMPILER_GNUC' since the value of 'VL_COMPILER_GNUC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
           , v) ;
^
vlfeat/vl/ikmeans.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/ikmeans_elkan.tc:67:27: style: The scope of the variable 'cx' can be reduced. [variableScope]
  vl_uindex i,pass,c,cp,x,cx ;
                          ^
vlfeat/vl/ikmeans_elkan.tc:80:7: style: The scope of the variable 'done' can be reduced. [variableScope]
  int done = 0 ;
      ^
vlfeat/vl/ikmeans_elkan.tc:326:17: style: The scope of the variable 'cx' can be reduced. [variableScope]
  vl_uindex i,c,cx,x ;
                ^
vlfeat/vl/ikmeans_elkan.tc:328:21: style: The scope of the variable 'best_dist' can be reduced. [variableScope]
  vl_ikmacc_t dist, best_dist ;
                    ^
vlfeat/vl/ikmeans_elkan.tc:143:11: style: Local variable 'cx' shadows outer variable [shadowVariable]
      int cx = asgn[x] ;
          ^
vlfeat/vl/ikmeans_elkan.tc:67:27: note: Shadowed declaration
  vl_uindex i,pass,c,cp,x,cx ;
                          ^
vlfeat/vl/ikmeans_elkan.tc:143:11: note: Shadow variable
      int cx = asgn[x] ;
          ^
vlfeat/vl/ikmeans_elkan.tc:180:19: style: Local variable 'cx' shadows outer variable [shadowVariable]
        vl_uindex cx  = (int) asgn[x] ;
                  ^
vlfeat/vl/ikmeans_elkan.tc:67:27: note: Shadowed declaration
  vl_uindex i,pass,c,cp,x,cx ;
                          ^
vlfeat/vl/ikmeans_elkan.tc:180:19: note: Shadow variable
        vl_uindex cx  = (int) asgn[x] ;
                  ^
vlfeat/vl/ikmeans_elkan.tc:230:17: style: Local variable 'cx' shadows outer variable [shadowVariable]
      vl_uindex cx = (vl_uindex) asgn[x] ;
                ^
vlfeat/vl/ikmeans_elkan.tc:67:27: note: Shadowed declaration
  vl_uindex i,pass,c,cp,x,cx ;
                          ^
vlfeat/vl/ikmeans_elkan.tc:230:17: note: Shadow variable
      vl_uindex cx = (vl_uindex) asgn[x] ;
                ^
vlfeat/vl/ikmeans_elkan.tc:241:21: style: Local variable 'dist' shadows outer variable [shadowVariable]
        vl_ikmacc_t dist = 0 ;
                    ^
vlfeat/vl/ikmeans_elkan.tc:70:15: note: Shadowed declaration
  vl_ikmacc_t dist ;
              ^
vlfeat/vl/ikmeans_elkan.tc:241:21: note: Shadow variable
        vl_ikmacc_t dist = 0 ;
                    ^
vlfeat/vl/ikmeans_elkan.tc:80:12: style: Variable 'done' is assigned a value that is never used. [unreadVariable]
  int done = 0 ;
           ^
vlfeat/vl/imopv.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/imopv.c:769:11: style: Variable 'pgrad_x' is reassigned a value before the old one has been used. [redundantAssignment]
  pgrad_x = xGradient;
          ^
vlfeat/vl/imopv.c:763:11: note: pgrad_x is assigned
  pgrad_x += gradWidthStride;
          ^
vlfeat/vl/imopv.c:769:11: note: pgrad_x is overwritten
  pgrad_x = xGradient;
          ^
vlfeat/vl/imopv.c:771:11: style: Variable 'pgrad_y' is reassigned a value before the old one has been used. [redundantAssignment]
  pgrad_y = yGradient;
          ^
vlfeat/vl/imopv.c:765:11: note: pgrad_y is assigned
  pgrad_y += gradWidthStride;
          ^
vlfeat/vl/imopv.c:771:11: note: pgrad_y is overwritten
  pgrad_y = yGradient;
          ^
vlfeat/vl/imopv.c:773:7: style: Variable 'src' is reassigned a value before the old one has been used. [redundantAssignment]
  src = image;
      ^
vlfeat/vl/imopv.c:766:6: note: src is assigned
  src++;
     ^
vlfeat/vl/imopv.c:773:7: note: src is overwritten
  src = image;
      ^
vlfeat/vl/imopv.c:802:13: style: Variable 'pgrad_x' is reassigned a value before the old one has been used. [redundantAssignment]
    pgrad_x = xGradient;
            ^
vlfeat/vl/imopv.c:796:13: note: pgrad_x is assigned
    pgrad_x += gradWidthStride;
            ^
vlfeat/vl/imopv.c:802:13: note: pgrad_x is overwritten
    pgrad_x = xGradient;
            ^
vlfeat/vl/imopv.c:804:13: style: Variable 'pgrad_y' is reassigned a value before the old one has been used. [redundantAssignment]
    pgrad_y = yGradient;
            ^
vlfeat/vl/imopv.c:798:13: note: pgrad_y is assigned
    pgrad_y += gradWidthStride;
            ^
vlfeat/vl/imopv.c:804:13: note: pgrad_y is overwritten
    pgrad_y = yGradient;
            ^
vlfeat/vl/imopv.c:806:9: style: Variable 'src' is reassigned a value before the old one has been used. [redundantAssignment]
    src = image;
        ^
vlfeat/vl/imopv.c:799:8: note: src is assigned
    src++;
       ^
vlfeat/vl/imopv.c:806:9: note: src is overwritten
    src = image;
        ^
vlfeat/vl/imopv.c:922:14: style: Variable 'pgrad_ampl' is reassigned a value before the old one has been used. [redundantAssignment]
  pgrad_ampl = gradientModulus;
             ^
vlfeat/vl/imopv.c:919:3: note: pgrad_ampl is assigned
  SAVE_BACK ;
  ^
vlfeat/vl/imopv.c:922:14: note: pgrad_ampl is overwritten
  pgrad_ampl = gradientModulus;
             ^
vlfeat/vl/imopv.c:924:14: style: Variable 'pgrad_angl' is reassigned a value before the old one has been used. [redundantAssignment]
  pgrad_angl = gradientAngle;
             ^
vlfeat/vl/imopv.c:919:3: note: pgrad_angl is assigned
  SAVE_BACK ;
  ^
vlfeat/vl/imopv.c:924:14: note: pgrad_angl is overwritten
  pgrad_angl = gradientAngle;
             ^
vlfeat/vl/imopv.c:926:7: style: Variable 'src' is reassigned a value before the old one has been used. [redundantAssignment]
  src = image;
      ^
vlfeat/vl/imopv.c:919:3: note: src is assigned
  SAVE_BACK ;
  ^
vlfeat/vl/imopv.c:926:7: note: src is overwritten
  src = image;
      ^
vlfeat/vl/imopv.c:949:16: style: Variable 'pgrad_ampl' is reassigned a value before the old one has been used. [redundantAssignment]
    pgrad_ampl = gradientModulus;
               ^
vlfeat/vl/imopv.c:946:5: note: pgrad_ampl is assigned
    SAVE_BACK ;
    ^
vlfeat/vl/imopv.c:949:16: note: pgrad_ampl is overwritten
    pgrad_ampl = gradientModulus;
               ^
vlfeat/vl/imopv.c:951:16: style: Variable 'pgrad_angl' is reassigned a value before the old one has been used. [redundantAssignment]
    pgrad_angl = gradientAngle;
               ^
vlfeat/vl/imopv.c:946:5: note: pgrad_angl is assigned
    SAVE_BACK ;
    ^
vlfeat/vl/imopv.c:951:16: note: pgrad_angl is overwritten
    pgrad_angl = gradientAngle;
               ^
vlfeat/vl/imopv.c:953:9: style: Variable 'src' is reassigned a value before the old one has been used. [redundantAssignment]
    src = image;
        ^
vlfeat/vl/imopv.c:946:5: note: src is assigned
    SAVE_BACK ;
    ^
vlfeat/vl/imopv.c:953:9: note: src is overwritten
    src = image;
        ^
vlfeat/vl/imopv.c:158:14: style: The scope of the variable 'filti' can be reduced. [variableScope]
    T const *filti ;
             ^
vlfeat/vl/imopv.c:159:14: style: The scope of the variable 'stop' can be reduced. [variableScope]
    vl_index stop ;
             ^
vlfeat/vl/imopv.c:876:6: style:inconclusive: Function 'vl_imgradient_polar_f' argument 1 names different: declaration 'amplitudeGradient' definition 'gradientModulus'. [funcArgNamesDifferent]
(T * gradientModulus, T * gradientAngle,
     ^
vlfeat/vl/imopv.h:128:31: note: Function 'vl_imgradient_polar_f' argument 1 names different: declaration 'amplitudeGradient' definition 'gradientModulus'.
vl_imgradient_polar_f (float* amplitudeGradient, float* angleGradient,
                              ^
vlfeat/vl/imopv.c:876:6: note: Function 'vl_imgradient_polar_f' argument 1 names different: declaration 'amplitudeGradient' definition 'gradientModulus'.
(T * gradientModulus, T * gradientAngle,
     ^
vlfeat/vl/imopv.c:876:27: style:inconclusive: Function 'vl_imgradient_polar_f' argument 2 names different: declaration 'angleGradient' definition 'gradientAngle'. [funcArgNamesDifferent]
(T * gradientModulus, T * gradientAngle,
                          ^
vlfeat/vl/imopv.h:128:57: note: Function 'vl_imgradient_polar_f' argument 2 names different: declaration 'angleGradient' definition 'gradientAngle'.
vl_imgradient_polar_f (float* amplitudeGradient, float* angleGradient,
                                                        ^
vlfeat/vl/imopv.c:876:27: note: Function 'vl_imgradient_polar_f' argument 2 names different: declaration 'angleGradient' definition 'gradientAngle'.
(T * gradientModulus, T * gradientAngle,
                          ^
vlfeat/vl/imopv.c:877:10: style:inconclusive: Function 'vl_imgradient_polar_f' argument 3 names different: declaration 'gradWidthStride' definition 'gradientHorizontalStride'. [funcArgNamesDifferent]
 vl_size gradientHorizontalStride, vl_size gradHeightStride,
         ^
vlfeat/vl/imopv.h:129:32: note: Function 'vl_imgradient_polar_f' argument 3 names different: declaration 'gradWidthStride' definition 'gradientHorizontalStride'.
                       vl_size gradWidthStride, vl_size gradHeightStride,
                               ^
vlfeat/vl/imopv.c:877:10: note: Function 'vl_imgradient_polar_f' argument 3 names different: declaration 'gradWidthStride' definition 'gradientHorizontalStride'.
 vl_size gradientHorizontalStride, vl_size gradHeightStride,
         ^
vlfeat/vl/imopv.c:876:6: style:inconclusive: Function 'vl_imgradient_polar_d' argument 1 names different: declaration 'amplitudeGradient' definition 'gradientModulus'. [funcArgNamesDifferent]
(T * gradientModulus, T * gradientAngle,
     ^
vlfeat/vl/imopv.h:135:32: note: Function 'vl_imgradient_polar_d' argument 1 names different: declaration 'amplitudeGradient' definition 'gradientModulus'.
vl_imgradient_polar_d (double* amplitudeGradient, double* angleGradient,
                               ^
vlfeat/vl/imopv.c:876:6: note: Function 'vl_imgradient_polar_d' argument 1 names different: declaration 'amplitudeGradient' definition 'gradientModulus'.
(T * gradientModulus, T * gradientAngle,
     ^
vlfeat/vl/imopv.c:876:27: style:inconclusive: Function 'vl_imgradient_polar_d' argument 2 names different: declaration 'angleGradient' definition 'gradientAngle'. [funcArgNamesDifferent]
(T * gradientModulus, T * gradientAngle,
                          ^
vlfeat/vl/imopv.h:135:59: note: Function 'vl_imgradient_polar_d' argument 2 names different: declaration 'angleGradient' definition 'gradientAngle'.
vl_imgradient_polar_d (double* amplitudeGradient, double* angleGradient,
                                                          ^
vlfeat/vl/imopv.c:876:27: note: Function 'vl_imgradient_polar_d' argument 2 names different: declaration 'angleGradient' definition 'gradientAngle'.
(T * gradientModulus, T * gradientAngle,
                          ^
vlfeat/vl/imopv.c:877:10: style:inconclusive: Function 'vl_imgradient_polar_d' argument 3 names different: declaration 'gradWidthStride' definition 'gradientHorizontalStride'. [funcArgNamesDifferent]
 vl_size gradientHorizontalStride, vl_size gradHeightStride,
         ^
vlfeat/vl/imopv.h:136:32: note: Function 'vl_imgradient_polar_d' argument 3 names different: declaration 'gradWidthStride' definition 'gradientHorizontalStride'.
                       vl_size gradWidthStride, vl_size gradHeightStride,
                               ^
vlfeat/vl/imopv.c:877:10: note: Function 'vl_imgradient_polar_d' argument 3 names different: declaration 'gradWidthStride' definition 'gradientHorizontalStride'.
 vl_size gradientHorizontalStride, vl_size gradHeightStride,
         ^
vlfeat/vl/imopv.c:353:17: style: Variable 'num' is assigned a value that is never used. [unreadVariable]
  vl_uindex num = 0 ;
                ^
vlfeat/vl/imopv.c:972:3: style: Variable 'pgrad_ampl' is assigned a value that is never used. [unreadVariable]
  SAVE_BACK ;
  ^
vlfeat/vl/imopv.c:972:3: style: Variable 'pgrad_angl' is assigned a value that is never used. [unreadVariable]
  SAVE_BACK ;
  ^
vlfeat/vl/imopv.c:972:3: style: Variable 'src' is assigned a value that is never used. [unreadVariable]
  SAVE_BACK ;
  ^
vlfeat/vl/imopv_sse2.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 26 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/imopv_sse2.c:76:41: style:inconclusive: Boolean expression 'x+4<(int)src_width' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
    if ((x + VSIZE < (signed)src_width) &
                                        ^
vlfeat/vl/imopv_sse2.c:76:41: style:inconclusive: Boolean expression 'x+2<(int)src_width' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
    if ((x + VSIZE < (signed)src_width) &
                                        ^
vlfeat/vl/imopv_sse2.c:56:17: style: Variable 'totcol' is assigned a value that is never used. [unreadVariable]
  double totcol = 0 ;
                ^
vlfeat/vl/imopv_sse2.c:57:18: style: Variable 'simdcol' is assigned a value that is never used. [unreadVariable]
  double simdcol = 0 ;
                 ^
vlfeat/vl/imopv_sse2.c:144:15: style: Variable 'simdcol' is assigned a value that is never used. [unreadVariable]
      simdcol += VSIZE ;
              ^
vlfeat/vl/imopv_sse2.c:145:15: style: Variable 'totcol' is assigned a value that is never used. [unreadVariable]
      totcol  += VSIZE ;
              ^
vlfeat/vl/imopv_sse2.c:198:14: style: Variable 'totcol' is assigned a value that is never used. [unreadVariable]
      totcol += 1 ;
             ^
vlfeat/vl/kdtree.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 28 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/kdtree.c:448:24: style:inconclusive: Boolean expression 'i<pos' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  for(i = 0; (i < pos) & (lastSearcher != NULL) ; ++i) {
                       ^
vlfeat/vl/kdtree.c:463:13: style: The scope of the variable 'ti' can be reduced. [variableScope]
  vl_uindex ti ;
            ^
vlfeat/vl/kdtree.c:783:27: style: The scope of the variable 'searchState' can be reduced. [variableScope]
  VlKDForestSearchState * searchState  ;
                          ^
vlfeat/vl/kdtree.c:333:78: style:inconclusive: Function 'vl_kdforest_new' argument 4 names different: declaration 'normType' definition 'distance'. [funcArgNamesDifferent]
                 vl_size dimension, vl_size numTrees, VlVectorComparisonType distance)
                                                                             ^
vlfeat/vl/kdtree.h:138:101: note: Function 'vl_kdforest_new' argument 4 names different: declaration 'normType' definition 'distance'.
                                        vl_size dimension, vl_size numTrees, VlVectorComparisonType normType) ;
                                                                                                    ^
vlfeat/vl/kdtree.c:333:78: note: Function 'vl_kdforest_new' argument 4 names different: declaration 'normType' definition 'distance'.
                 vl_size dimension, vl_size numTrees, VlVectorComparisonType distance)
                                                                             ^
vlfeat/vl/kdtree.c:423:50: style:inconclusive: Function 'vl_kdforestsearcher_delete' argument 1 names different: declaration 'searcher' definition 'self'. [funcArgNamesDifferent]
vl_kdforestsearcher_delete (VlKDForestSearcher * self)
                                                 ^
vlfeat/vl/kdtree.h:141:65: note: Function 'vl_kdforestsearcher_delete' argument 1 names different: declaration 'searcher' definition 'self'.
VL_EXPORT void vl_kdforestsearcher_delete (VlKDForestSearcher * searcher) ;
                                                                ^
vlfeat/vl/kdtree.c:423:50: note: Function 'vl_kdforestsearcher_delete' argument 1 names different: declaration 'searcher' definition 'self'.
vl_kdforestsearcher_delete (VlKDForestSearcher * self)
                                                 ^
vlfeat/vl/kdtree.c:871:43: style:inconclusive: Function 'vl_kdforest_query_with_array' argument 2 names different: declaration 'index' definition 'indexes'. [funcArgNamesDifferent]
                              vl_uint32 * indexes,
                                          ^
vlfeat/vl/kdtree.h:156:61: note: Function 'vl_kdforest_query_with_array' argument 2 names different: declaration 'index' definition 'indexes'.
                                                vl_uint32 * index,
                                                            ^
vlfeat/vl/kdtree.c:871:43: note: Function 'vl_kdforest_query_with_array' argument 2 names different: declaration 'index' definition 'indexes'.
                              vl_uint32 * indexes,
                                          ^
vlfeat/vl/kdtree.c:874:38: style:inconclusive: Function 'vl_kdforest_query_with_array' argument 5 names different: declaration 'distance' definition 'distances'. [funcArgNamesDifferent]
                              void * distances,
                                     ^
vlfeat/vl/kdtree.h:159:56: note: Function 'vl_kdforest_query_with_array' argument 5 names different: declaration 'distance' definition 'distances'.
                                                void * distance,
                                                       ^
vlfeat/vl/kdtree.c:874:38: note: Function 'vl_kdforest_query_with_array' argument 5 names different: declaration 'distance' definition 'distances'.
                              void * distances,
                                     ^
vlfeat/vl/kdtree.c:234:32: style: Local variable 'splitDimension' shadows outer variable [shadowVariable]
      VlKDTreeSplitDimension * splitDimension
                               ^
vlfeat/vl/kdtree.c:174:28: note: Shadowed declaration
  VlKDTreeSplitDimension * splitDimension ;
                           ^
vlfeat/vl/kdtree.c:234:32: note: Shadow variable
      VlKDTreeSplitDimension * splitDimension
                               ^
vlfeat/vl/kdtree.c:241:32: style: Local variable 'splitDimension' shadows outer variable [shadowVariable]
      VlKDTreeSplitDimension * splitDimension = forest->splitHeapArray + 0 ;
                               ^
vlfeat/vl/kdtree.c:174:28: note: Shadowed declaration
  VlKDTreeSplitDimension * splitDimension ;
                           ^
vlfeat/vl/kdtree.c:241:32: note: Shadow variable
      VlKDTreeSplitDimension * splitDimension = forest->splitHeapArray + 0 ;
                               ^
vlfeat/vl/kdtree.c:812:29: style: Local variable 'searchState' shadows outer variable [shadowVariable]
    VlKDForestSearchState * searchState ;
                            ^
vlfeat/vl/kdtree.c:783:27: note: Shadowed declaration
  VlKDForestSearchState * searchState  ;
                          ^
vlfeat/vl/kdtree.c:812:29: note: Shadow variable
    VlKDForestSearchState * searchState ;
                            ^
vlfeat/vl/kmeans.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 32 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/kmeans.c:846:11: style: The scope of the variable 'numRestartedCenters' can be reduced. [variableScope]
  vl_size numRestartedCenters = 0 ;
          ^
vlfeat/vl/kmeans.c:1018:11: style: The scope of the variable 'numRestartedCenters' can be reduced. [variableScope]
  vl_size numRestartedCenters = 0 ;
          ^
vlfeat/vl/kmeans.c:1844:10: style:inconclusive: Function 'vl_kmeans_init_centers_with_rand_data' argument 3 names different: declaration 'dimensions' definition 'dimension'. [funcArgNamesDifferent]
 vl_size dimension,
         ^
vlfeat/vl/kmeans.h:114:28: note: Function 'vl_kmeans_init_centers_with_rand_data' argument 3 names different: declaration 'dimensions' definition 'dimension'.
                   vl_size dimensions,
                           ^
vlfeat/vl/kmeans.c:1844:10: note: Function 'vl_kmeans_init_centers_with_rand_data' argument 3 names different: declaration 'dimensions' definition 'dimension'.
 vl_size dimension,
         ^
vlfeat/vl/kmeans.c:1877:10: style:inconclusive: Function 'vl_kmeans_init_centers_plus_plus' argument 3 names different: declaration 'dimensions' definition 'dimension'. [funcArgNamesDifferent]
 vl_size dimension,
         ^
vlfeat/vl/kmeans.h:121:28: note: Function 'vl_kmeans_init_centers_plus_plus' argument 3 names different: declaration 'dimensions' definition 'dimension'.
                   vl_size dimensions,
                           ^
vlfeat/vl/kmeans.c:1877:10: note: Function 'vl_kmeans_init_centers_plus_plus' argument 3 names different: declaration 'dimensions' definition 'dimension'.
 vl_size dimension,
         ^
vlfeat/vl/kmeans.c:924:23: style: Local variable 'x' shadows outer variable [shadowVariable]
            vl_uindex x = vl_rand_uindex(rand, numData) ;
                      ^
vlfeat/vl/kmeans.c:834:17: note: Shadowed declaration
  vl_size c, d, x, iteration ;
                ^
vlfeat/vl/kmeans.c:924:23: note: Shadow variable
            vl_uindex x = vl_rand_uindex(rand, numData) ;
                      ^
vlfeat/vl/kmeans.c:948:25: style: Local variable 'x' shadows outer variable [shadowVariable]
              vl_uindex x = vl_rand_uindex(rand, numData) ;
                        ^
vlfeat/vl/kmeans.c:834:17: note: Shadowed declaration
  vl_size c, d, x, iteration ;
                ^
vlfeat/vl/kmeans.c:948:25: note: Shadow variable
              vl_uindex x = vl_rand_uindex(rand, numData) ;
                        ^
vlfeat/vl/kmeans.c:1100:23: style: Local variable 'x' shadows outer variable [shadowVariable]
            vl_uindex x = vl_rand_uindex(rand, numData) ;
                      ^
vlfeat/vl/kmeans.c:1009:17: note: Shadowed declaration
  vl_size c, d, x, iteration ;
                ^
vlfeat/vl/kmeans.c:1100:23: note: Shadow variable
            vl_uindex x = vl_rand_uindex(rand, numData) ;
                      ^
vlfeat/vl/kmeans.c:1124:25: style: Local variable 'x' shadows outer variable [shadowVariable]
              vl_uindex x = vl_rand_uindex(rand, numData) ;
                        ^
vlfeat/vl/kmeans.c:1009:17: note: Shadowed declaration
  vl_size c, d, x, iteration ;
                ^
vlfeat/vl/kmeans.c:1124:25: note: Shadow variable
              vl_uindex x = vl_rand_uindex(rand, numData) ;
                        ^
vlfeat/vl/kmeans.c:1338:23: style: Local variable 'x' shadows outer variable [shadowVariable]
            vl_uindex x = vl_rand_uindex(rand, numData) ;
                      ^
vlfeat/vl/kmeans.c:1169:12: note: Shadowed declaration
  vl_index x ;
           ^
vlfeat/vl/kmeans.c:1338:23: note: Shadow variable
            vl_uindex x = vl_rand_uindex(rand, numData) ;
                      ^
vlfeat/vl/kmeans.c:1363:23: style: Local variable 'x' shadows outer variable [shadowVariable]
            vl_uindex x = vl_rand_uindex(rand, numData) ;
                      ^
vlfeat/vl/kmeans.c:1169:12: note: Shadowed declaration
  vl_index x ;
           ^
vlfeat/vl/kmeans.c:1363:23: note: Shadow variable
            vl_uindex x = vl_rand_uindex(rand, numData) ;
                      ^
vlfeat/vl/kmeans.c:846:31: style: Variable 'numRestartedCenters' is assigned a value that is never used. [unreadVariable]
  vl_size numRestartedCenters = 0 ;
                              ^
vlfeat/vl/kmeans.c:1018:31: style: Variable 'numRestartedCenters' is assigned a value that is never used. [unreadVariable]
  vl_size numRestartedCenters = 0 ;
                              ^
vlfeat/vl/kmeans.c:486:15: style: struct member '_VlKMeansSortWrapper::permutation' is never used. [unusedStructMember]
  vl_uint32 * permutation ;
              ^
vlfeat/vl/kmeans.c:487:16: style: struct member '_VlKMeansSortWrapper::data' is never used. [unusedStructMember]
  void const * data ;
               ^
vlfeat/vl/kmeans.c:488:11: style: struct member '_VlKMeansSortWrapper::stride' is never used. [unusedStructMember]
  vl_size stride ;
          ^
vlfeat/vl/lbp.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/lbp.c:318:22: style:inconclusive: Boolean expression 'cx1>=0' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
      if ((cx1 >= 0) & (cy1 >=0)) {
                     ^
vlfeat/vl/lbp.c:321:35: style:inconclusive: Boolean expression 'cx2<(int)cwidth' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
      if ((cx2 < (signed)cwidth)  & (cy1 >=0)) {
                                  ^
vlfeat/vl/lbp.c:324:22: style:inconclusive: Boolean expression 'cx1>=0' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
      if ((cx1 >= 0) & (cy2 < (signed)cheight)) {
                     ^
vlfeat/vl/lbp.c:327:34: style:inconclusive: Boolean expression 'cx2<(int)cwidth' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
      if ((cx2 < (signed)cwidth) & (cy2 < (signed)cheight)) {
                                 ^
vlfeat/vl/liop.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 25 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/liop.c:442:35: style:inconclusive: Function 'vl_liopdesc_process' argument 1 names different: declaration 'liop' definition 'self'. [funcArgNamesDifferent]
vl_liopdesc_process (VlLiopDesc * self, float * desc, float const * patch)
                                  ^
vlfeat/vl/liop.h:74:40: note: Function 'vl_liopdesc_process' argument 1 names different: declaration 'liop' definition 'self'.
void vl_liopdesc_process (VlLiopDesc * liop, float * desc, float const * patch) ;
                                       ^
vlfeat/vl/liop.c:442:35: note: Function 'vl_liopdesc_process' argument 1 names different: declaration 'liop' definition 'self'.
vl_liopdesc_process (VlLiopDesc * self, float * desc, float const * patch)
                                  ^
vlfeat/vl/liop.c:349:12: style: Local variable 't' shadows outer variable [shadowVariable]
    double t = center - radius + 0.6 ;
           ^
vlfeat/vl/liop.c:324:15: note: Shadowed declaration
  vl_index i, t ;
              ^
vlfeat/vl/liop.c:349:12: note: Shadow variable
    double t = center - radius + 0.6 ;
           ^
vlfeat/vl/liop.c:533:14: style: Local variable 't' shadows outer variable [shadowVariable]
      int k, t ;
             ^
vlfeat/vl/liop.c:444:14: note: Shadowed declaration
  vl_index i,t ;
             ^
vlfeat/vl/liop.c:533:14: note: Shadow variable
      int k, t ;
             ^
vlfeat/vl/mathop.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/mathop.c:317:12: style: Opposite expression on both sides of '>'. [oppositeExpression]
    acc += VL_MAX(d, -d) ;
           ^
vlfeat/vl/mathop.c:728:7: style: The scope of the variable 'glarge' can be reduced. [variableScope]
  int glarge = 0 ; /* is g very large */
      ^
vlfeat/vl/mathop.c:730:10: style: The scope of the variable 'fmh' can be reduced. [variableScope]
  double fmh ; /* |f| -|h| */
         ^
vlfeat/vl/mathop.c:731:10: style: The scope of the variable 'd' can be reduced. [variableScope]
  double d ; /* (|f| -|h|)/|f| */
         ^
vlfeat/vl/mathop.c:732:10: style: The scope of the variable 'dd' can be reduced. [variableScope]
  double dd ; /* d*d */
         ^
vlfeat/vl/mathop.c:733:10: style: The scope of the variable 'q' can be reduced. [variableScope]
  double q ; /* g/f */
         ^
vlfeat/vl/mathop.c:734:10: style: The scope of the variable 'qq' can be reduced. [variableScope]
  double qq ; /* q*q */
         ^
vlfeat/vl/mathop.c:735:10: style: The scope of the variable 's' can be reduced. [variableScope]
  double s ; /* (|f| + |h|)/|f| */
         ^
vlfeat/vl/mathop.c:736:10: style: The scope of the variable 'ss' can be reduced. [variableScope]
  double ss ; /* s*s */
         ^
vlfeat/vl/mathop.c:737:10: style: The scope of the variable 'spq' can be reduced. [variableScope]
  double spq ; /* sqrt(ss + qq) */
         ^
vlfeat/vl/mathop.c:738:10: style: The scope of the variable 'dpq' can be reduced. [variableScope]
  double dpq ; /* sqrt(dd + qq) */
         ^
vlfeat/vl/mathop.c:739:10: style: The scope of the variable 'a' can be reduced. [variableScope]
  double a ; /* (spq + dpq)/2 */
         ^
vlfeat/vl/mathop.c:741:10: style: The scope of the variable 'tt' can be reduced. [variableScope]
  double tt;
         ^
vlfeat/vl/mathop_avx.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/mathop_avx.c:77:40: style:inconclusive: Boolean expression '!(((vl_uintptr)(X))&0x1F)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNEDavx(X) & VALIGNEDavx(Y) ;
                                       ^
vlfeat/vl/mathop_avx.c:121:40: style:inconclusive: Boolean expression '!(((vl_uintptr)(X))&0x1F)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNEDavx(X) & VALIGNEDavx(MU) & VALIGNEDavx(S);
                                       ^
vlfeat/vl/mathop_avx.c:121:58: style:inconclusive: Boolean expression '!(((vl_uintptr)(S))&0x1F)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNEDavx(X) & VALIGNEDavx(MU) & VALIGNEDavx(S);
                                                         ^
vlfeat/vl/mathop_avx.c:178:40: style:inconclusive: Boolean expression '!(((vl_uintptr)(X))&0x1F)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNEDavx(X) & VALIGNEDavx(MU);
                                       ^
vlfeat/vl/mathop_avx.c:223:40: style:inconclusive: Boolean expression '!(((vl_uintptr)(X))&0x1F)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNEDavx(X) & VALIGNEDavx(Y) & VALIGNEDavx(S);
                                       ^
vlfeat/vl/mathop_avx.c:223:57: style:inconclusive: Boolean expression '!(((vl_uintptr)(S))&0x1F)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNEDavx(X) & VALIGNEDavx(Y) & VALIGNEDavx(S);
                                                        ^
vlfeat/vl/mathop_sse2.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 25 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/mathop_sse2.c:84:37: style:inconclusive: Boolean expression '!(((vl_uintptr)(X))&0xF)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNED(X) & VALIGNED(Y) ;
                                    ^
vlfeat/vl/mathop_sse2.c:125:37: style:inconclusive: Boolean expression '!(((vl_uintptr)(X))&0xF)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNED(X) & VALIGNED(Y) ;
                                    ^
vlfeat/vl/mathop_sse2.c:169:37: style:inconclusive: Boolean expression '!(((vl_uintptr)(X))&0xF)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNED(X) & VALIGNED(MU) & VALIGNED(S);
                                    ^
vlfeat/vl/mathop_sse2.c:169:52: style:inconclusive: Boolean expression '!(((vl_uintptr)(S))&0xF)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNED(X) & VALIGNED(MU) & VALIGNED(S);
                                                   ^
vlfeat/vl/mathop_sse2.c:230:37: style:inconclusive: Boolean expression '!(((vl_uintptr)(X))&0xF)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNED(X) & VALIGNED(Y) ;
                                    ^
vlfeat/vl/mathop_sse2.c:272:37: style:inconclusive: Boolean expression '!(((vl_uintptr)(X))&0xF)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNED(X) & VALIGNED(Y) ;
                                    ^
vlfeat/vl/mathop_sse2.c:327:37: style:inconclusive: Boolean expression '!(((vl_uintptr)(X))&0xF)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNED(X) & VALIGNED(Y) ;
                                    ^
vlfeat/vl/mathop_sse2.c:366:37: style:inconclusive: Boolean expression '!(((vl_uintptr)(X))&0xF)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNED(X) & VALIGNED(Y) ;
                                    ^
vlfeat/vl/mathop_sse2.c:417:37: style:inconclusive: Boolean expression '!(((vl_uintptr)(X))&0xF)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNED(X) & VALIGNED(Y) ;
                                    ^
vlfeat/vl/mathop_sse2.c:466:37: style:inconclusive: Boolean expression '!(((vl_uintptr)(X))&0xF)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNED(X) & VALIGNED(Y) & VALIGNED(S);
                                    ^
vlfeat/vl/mathop_sse2.c:466:51: style:inconclusive: Boolean expression '!(((vl_uintptr)(S))&0xF)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNED(X) & VALIGNED(Y) & VALIGNED(S);
                                                  ^
vlfeat/vl/mathop_sse2.c:523:37: style:inconclusive: Boolean expression '!(((vl_uintptr)(X))&0xF)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  vl_bool dataAligned = VALIGNED(X) & VALIGNED(MU);
                                    ^
vlfeat/vl/mathop_sse2.c:258:12: style: Opposite expression on both sides of '>'. [oppositeExpression]
    acc += VL_MAX(delta, - delta) ;
           ^
vlfeat/vl/mser.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/mser.c:918:7: style: Redundant initialization for 'acc'. The initialized value is overwritten before it is read. [redundantInitialization]
  acc = f-> acc ;
      ^
vlfeat/vl/mser.c:899:26: note: acc is initialized
  vl_mser_acc       *acc = f-> acc ;
                         ^
vlfeat/vl/mser.c:918:7: note: acc is overwritten
  acc = f-> acc ;
      ^
vlfeat/vl/mser.c:919:7: style: Redundant initialization for 'ell'. The initialized value is overwritten before it is read. [redundantInitialization]
  ell = f-> ell ;
      ^
vlfeat/vl/mser.c:900:26: note: ell is initialized
  vl_mser_acc       *ell = f-> ell ;
                         ^
vlfeat/vl/mser.c:919:7: note: ell is overwritten
  ell = f-> ell ;
      ^
vlfeat/vl/mser.c:266:11: style: The scope of the variable 'next_idx' can be reduced. [variableScope]
  vl_uint next_idx ;
          ^
vlfeat/vl/mser.c:556:21: style: The scope of the variable 'nr_val' can be reduced. [variableScope]
        vl_mser_pix nr_val = 0 ;
                    ^
vlfeat/vl/mser.c:473:15: style: Local variable 'j' shadows outer variable [shadowVariable]
      vl_uint j = -- buckets [v] ;
              ^
vlfeat/vl/mser.c:443:10: note: Shadowed declaration
  int i, j, k ;
         ^
vlfeat/vl/mser.c:473:15: note: Shadow variable
      vl_uint j = -- buckets [v] ;
              ^
vlfeat/vl/mser.c:959:15: style: Local variable 'index' shadows outer variable [shadowVariable]
      vl_uint index  = joins [i] ;
              ^
vlfeat/vl/mser.c:902:10: note: Shadowed declaration
  int d, index, i, j ;
         ^
vlfeat/vl/mser.c:959:15: note: Shadow variable
      vl_uint index  = joins [i] ;
              ^
vlfeat/vl/pgm.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 22 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/pgm.c:236:18: warning: Comparison of a boolean expression with an integer other than 0 or 1. [compareBoolExpressionWithInt]
  if(! max_value >= 65536) {
                 ^
vlfeat/vl/pgm.c:421:3: error: Resource handle 'f' freed twice. [doubleFree]
  fclose (f) ;
  ^
vlfeat/vl/pgm.c:418:5: note: Resource handle 'f' freed twice.
    fclose (f) ;
    ^
vlfeat/vl/pgm.c:421:3: note: Resource handle 'f' freed twice.
  fclose (f) ;
  ^
vlfeat/vl/quickshift.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/quickshift.h:179:38: style:inconclusive: Function 'vl_quickshift_set_kernel_size' argument 1 names different: declaration 'f' definition 'q'. [funcArgNamesDifferent]
vl_quickshift_set_kernel_size (VlQS *q, vl_qs_type sigma)
                                     ^
vlfeat/vl/quickshift.h:85:54: note: Function 'vl_quickshift_set_kernel_size' argument 1 names different: declaration 'f' definition 'q'.
VL_INLINE void vl_quickshift_set_kernel_size  (VlQS *f, vl_qs_type sigma) ;
                                                     ^
vlfeat/vl/quickshift.h:179:38: note: Function 'vl_quickshift_set_kernel_size' argument 1 names different: declaration 'f' definition 'q'.
vl_quickshift_set_kernel_size (VlQS *q, vl_qs_type sigma)
                                     ^
vlfeat/vl/quickshift.h:192:35: style:inconclusive: Function 'vl_quickshift_set_max_dist' argument 1 names different: declaration 'f' definition 'q'. [funcArgNamesDifferent]
vl_quickshift_set_max_dist (VlQS *q, vl_qs_type tau)
                                  ^
vlfeat/vl/quickshift.h:84:53: note: Function 'vl_quickshift_set_max_dist' argument 1 names different: declaration 'f' definition 'q'.
VL_INLINE void vl_quickshift_set_max_dist    (VlQS *f, vl_qs_type tau) ;
                                                    ^
vlfeat/vl/quickshift.h:192:35: note: Function 'vl_quickshift_set_max_dist' argument 1 names different: declaration 'f' definition 'q'.
vl_quickshift_set_max_dist (VlQS *q, vl_qs_type tau)
                                  ^
vlfeat/vl/quickshift.h:205:33: style:inconclusive: Function 'vl_quickshift_set_medoid' argument 1 names different: declaration 'f' definition 'q'. [funcArgNamesDifferent]
vl_quickshift_set_medoid (VlQS *q, vl_bool medoid)
                                ^
vlfeat/vl/quickshift.h:86:48: note: Function 'vl_quickshift_set_medoid' argument 1 names different: declaration 'f' definition 'q'.
VL_INLINE void vl_quickshift_set_medoid (VlQS *f, vl_bool medoid) ;
                                               ^
vlfeat/vl/quickshift.h:205:33: note: Function 'vl_quickshift_set_medoid' argument 1 names different: declaration 'f' definition 'q'.
vl_quickshift_set_medoid (VlQS *q, vl_bool medoid)
                                ^
vlfeat/vl/quickshift.c:231:38: style:inconclusive: Function 'vl_quickshift_new' argument 1 names different: declaration 'im' definition 'image'. [funcArgNamesDifferent]
vl_quickshift_new(vl_qs_type const * image, int height, int width,
                                     ^
vlfeat/vl/quickshift.h:53:46: note: Function 'vl_quickshift_new' argument 1 names different: declaration 'im' definition 'image'.
VlQS*  vl_quickshift_new (vl_qs_type const * im, int height, int width,
                                             ^
vlfeat/vl/quickshift.c:231:38: note: Function 'vl_quickshift_new' argument 1 names different: declaration 'im' definition 'image'.
vl_quickshift_new(vl_qs_type const * image, int height, int width,
                                     ^
vlfeat/vl/random.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/random.c:210:15: style: The scope of the variable 'j' can be reduced. [variableScope]
  vl_index i, j, tmp;
              ^
vlfeat/vl/random.c:210:18: style: The scope of the variable 'tmp' can be reduced. [variableScope]
  vl_index i, j, tmp;
                 ^
vlfeat/vl/random.c:228:20: style: The scope of the variable 'mag01' can be reduced. [variableScope]
  static vl_uint32 mag01[2]={VL_UINT32_C(0x0), MATRIX_A};
                   ^
vlfeat/vl/rodrigues.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/rodrigues.c:273:12: style: The scope of the variable 'b' can be reduced. [variableScope]
    double b ;
           ^
vlfeat/vl/scalespace.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/scalespace.c:568:16: style: Redundant initialization for 'numSublevels'. The initialized value is overwritten before it is read. [redundantInitialization]
  numSublevels = geom.octaveLastSubdivision - geom.octaveFirstSubdivision + 1 ;
               ^
vlfeat/vl/scalespace.c:562:24: note: numSublevels is initialized
  vl_size numSublevels = geom.octaveLastSubdivision - geom.octaveFirstSubdivision + 1 ;
                       ^
vlfeat/vl/scalespace.c:568:16: note: numSublevels is overwritten
  numSublevels = geom.octaveLastSubdivision - geom.octaveFirstSubdivision + 1 ;
               ^
vlfeat/vl/scalespace.c:567:14: style: Redundant initialization for 'numOctaves'. The initialized value is overwritten before it is read. [redundantInitialization]
  numOctaves = geom.lastOctave - geom.firstOctave + 1 ;
             ^
vlfeat/vl/scalespace.c:563:22: note: numOctaves is initialized
  vl_size numOctaves = geom.lastOctave - geom.firstOctave + 1 ;
                     ^
vlfeat/vl/scalespace.c:567:14: note: numOctaves is overwritten
  numOctaves = geom.lastOctave - geom.firstOctave + 1 ;
             ^
vlfeat/vl/scalespace.c:455:22: style: The scope of the variable 'oy' can be reduced. [variableScope]
  vl_index x, y, ox, oy ;
                     ^
vlfeat/vl/scalespace.c:456:14: style: The scope of the variable 'v10' can be reduced. [variableScope]
  float v00, v10, v01, v11 ;
             ^
vlfeat/vl/scalespace.c:456:24: style: The scope of the variable 'v11' can be reduced. [variableScope]
  float v00, v10, v01, v11 ;
                       ^
vlfeat/vl/scalespace.c:503:12: style: The scope of the variable 'x' can be reduced. [variableScope]
  vl_index x, y ;
           ^
vlfeat/vl/scalespace.c:503:15: style: The scope of the variable 'y' can be reduced. [variableScope]
  vl_index x, y ;
              ^
vlfeat/vl/scalespace.c:604:39: style:inconclusive: Function 'vl_scalespace_new_copy' argument 1 names different: declaration 'src' definition 'self'. [funcArgNamesDifferent]
vl_scalespace_new_copy (VlScaleSpace* self)
                                      ^
vlfeat/vl/scalespace.h:72:64: note: Function 'vl_scalespace_new_copy' argument 1 names different: declaration 'src' definition 'self'.
VL_EXPORT VlScaleSpace * vl_scalespace_new_copy (VlScaleSpace* src);
                                                               ^
vlfeat/vl/scalespace.c:604:39: note: Function 'vl_scalespace_new_copy' argument 1 names different: declaration 'src' definition 'self'.
vl_scalespace_new_copy (VlScaleSpace* self)
                                      ^
vlfeat/vl/scalespace.c:629:47: style:inconclusive: Function 'vl_scalespace_new_shallow_copy' argument 1 names different: declaration 'src' definition 'self'. [funcArgNamesDifferent]
vl_scalespace_new_shallow_copy (VlScaleSpace* self)
                                              ^
vlfeat/vl/scalespace.h:73:72: note: Function 'vl_scalespace_new_shallow_copy' argument 1 names different: declaration 'src' definition 'self'.
VL_EXPORT VlScaleSpace * vl_scalespace_new_shallow_copy (VlScaleSpace* src);
                                                                       ^
vlfeat/vl/scalespace.c:629:47: note: Function 'vl_scalespace_new_shallow_copy' argument 1 names different: declaration 'src' definition 'self'.
vl_scalespace_new_shallow_copy (VlScaleSpace* self)
                                              ^
vlfeat/vl/scalespace.c:792:32: style: Local variable 'ogeom' shadows outer variable [shadowVariable]
    VlScaleSpaceOctaveGeometry ogeom = vl_scalespace_get_octave_geometry(self, o) ;
                               ^
vlfeat/vl/scalespace.c:761:30: note: Shadowed declaration
  VlScaleSpaceOctaveGeometry ogeom ;
                             ^
vlfeat/vl/scalespace.c:792:32: note: Shadow variable
    VlScaleSpaceOctaveGeometry ogeom = vl_scalespace_get_octave_geometry(self, o) ;
                               ^
vlfeat/vl/sift.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/sift.c:1199:0: error: failed to expand 'CHECK_NEIGHBORS', Invalid ## usage when expanding 'CHECK_NEIGHBORS'. [preprocessorErrorDirective]
#define CHECK_NEIGHBORS(CMP,SGN)                    \
^
vlfeat/vl/sift.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. Use -v for more details. [noValidConfiguration]

^
vlfeat/vl/slic.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/slic.c:265:18: style: Local variable 'u' shadows outer variable [shadowVariable]
        vl_index u = floor((double)x / regionSize - 0.5) ;
                 ^
vlfeat/vl/slic.c:179:21: note: Shadowed declaration
  vl_index i, x, y, u, v, k, region ;
                    ^
vlfeat/vl/slic.c:265:18: note: Shadow variable
        vl_index u = floor((double)x / regionSize - 0.5) ;
                 ^
vlfeat/vl/slic.c:266:18: style: Local variable 'v' shadows outer variable [shadowVariable]
        vl_index v = floor((double)y / regionSize - 0.5) ;
                 ^
vlfeat/vl/slic.c:179:24: note: Shadowed declaration
  vl_index i, x, y, u, v, k, region ;
                       ^
vlfeat/vl/slic.c:266:18: note: Shadow variable
        vl_index v = floor((double)y / regionSize - 0.5) ;
                 ^
vlfeat/vl/slic.c:272:22: style: Local variable 'region' shadows outer variable [shadowVariable]
            vl_index region = up  + vp * numRegionsX ;
                     ^
vlfeat/vl/slic.c:179:30: note: Shadowed declaration
  vl_index i, x, y, u, v, k, region ;
                             ^
vlfeat/vl/slic.c:272:22: note: Shadow variable
            vl_index region = up  + vp * numRegionsX ;
                     ^
vlfeat/vl/slic.c:315:18: style: Local variable 'region' shadows outer variable [shadowVariable]
        vl_index region = segmentation[pixel] ;
                 ^
vlfeat/vl/slic.c:179:30: note: Shadowed declaration
  vl_index i, x, y, u, v, k, region ;
                             ^
vlfeat/vl/slic.c:315:18: note: Shadow variable
        vl_index region = segmentation[pixel] ;
                 ^
vlfeat/vl/slic.c:370:34: warning: Expression 'yp' can have a negative value. That is converted to an unsigned value and used in an unsigned calculation. [signConversionCond]
        vl_index neighbor = xp + yp * width ;
                                 ^
vlfeat/vl/slic.c:372:15: note: Assuming that condition '0<=yp' is not redundant
            0 <= yp && yp < (signed)height &&
              ^
vlfeat/vl/slic.c:370:34: note: Negative value is converted to an unsigned value
        vl_index neighbor = xp + yp * width ;
                                 ^
vlfeat/vl/slic.c:386:36: warning: Expression 'yp' can have a negative value. That is converted to an unsigned value and used in an unsigned calculation. [signConversionCond]
          vl_index neighbor = xp + yp * width ;
                                   ^
vlfeat/vl/slic.c:388:17: note: Assuming that condition '0<=yp' is not redundant
              0 <= yp && yp < (signed)height &&
                ^
vlfeat/vl/slic.c:386:36: note: Negative value is converted to an unsigned value
          vl_index neighbor = xp + yp * width ;
                                   ^
vlfeat/vl/stringop.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/stringop.c:126:30: style:inconclusive: Function 'vl_string_protocol_name' argument 1 names different: declaration 'prot' definition 'protocol'. [funcArgNamesDifferent]
vl_string_protocol_name (int protocol)
                             ^
vlfeat/vl/stringop.h:32:52: note: Function 'vl_string_protocol_name' argument 1 names different: declaration 'prot' definition 'protocol'.
VL_EXPORT char const *vl_string_protocol_name (int prot) ;
                                                   ^
vlfeat/vl/stringop.c:126:30: note: Function 'vl_string_protocol_name' argument 1 names different: declaration 'prot' definition 'protocol'.
vl_string_protocol_name (int protocol)
                             ^
vlfeat/vl/stringop.c:166:29: style:inconclusive: Function 'vl_string_basename' argument 4 names different: declaration 'maxNumStrippedExtension' definition 'maxNumStrippedExtensions'. [funcArgNamesDifferent]
                    vl_size maxNumStrippedExtensions)
                            ^
vlfeat/vl/stringop.h:34:67: note: Function 'vl_string_basename' argument 4 names different: declaration 'maxNumStrippedExtension' definition 'maxNumStrippedExtensions'.
                                      char const *source, vl_size maxNumStrippedExtension) ;
                                                                  ^
vlfeat/vl/stringop.c:166:29: note: Function 'vl_string_basename' argument 4 names different: declaration 'maxNumStrippedExtension' definition 'maxNumStrippedExtensions'.
                    vl_size maxNumStrippedExtensions)
                            ^
vlfeat/vl/stringop.c:216:42: style:inconclusive: Function 'vl_string_replace_wildcard' argument 3 names different: declaration 'src' definition 'source'. [funcArgNamesDifferent]
                            char const * source,
                                         ^
vlfeat/vl/stringop.h:36:59: note: Function 'vl_string_replace_wildcard' argument 3 names different: declaration 'src' definition 'source'.
                                              char const *src, char wildcardChar, char escapeChar,
                                                          ^
vlfeat/vl/stringop.c:216:42: note: Function 'vl_string_replace_wildcard' argument 3 names different: declaration 'src' definition 'source'.
                            char const * source,
                                         ^
vlfeat/vl/svm.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/svm.c:1852:24: style:inconclusive: Boolean expression 't<2' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  for (t = 0 ; (t < 2) & (beta > VL_EPSILON_D) & (beta < 1-VL_EPSILON_D) ; ++t) {
                       ^
vlfeat/vl/svm.c:1852:48: style:inconclusive: Boolean expression 'beta<1-2.220446049250313e-16' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
  for (t = 0 ; (t < 2) & (beta > VL_EPSILON_D) & (beta < 1-VL_EPSILON_D) ; ++t) {
                                               ^
vlfeat/vl/svm.c:1764:12: style: Expression 'log(1 + x)' can be replaced by 'log1p(x)' to avoid loss of precision. [unpreciseMathCall]
    return log(1.0 + exp(-z)) ;
           ^
vlfeat/vl/svm.c:1766:17: style: Expression 'log(1 + x)' can be replaced by 'log1p(x)' to avoid loss of precision. [unpreciseMathCall]
    return -z + log(exp(z) + 1.0) ;
                ^
vlfeat/vl/svm.c:1874:17: style: The scope of the variable 'p' can be reduced. [variableScope]
  double inner, p ;
                ^
vlfeat/vl/svm.c:1936:36: style: The scope of the variable 'p' can be reduced. [variableScope]
  double inner, delta, multiplier, p ;
                                   ^
vlfeat/vl/svm.c:2024:10: style: The scope of the variable 'inner' can be reduced. [variableScope]
  double inner, gradient, rate, biasRate, p ;
         ^
vlfeat/vl/svm.c:2024:17: style: The scope of the variable 'gradient' can be reduced. [variableScope]
  double inner, gradient, rate, biasRate, p ;
                ^
vlfeat/vl/svm.c:2024:27: style: The scope of the variable 'rate' can be reduced. [variableScope]
  double inner, gradient, rate, biasRate, p ;
                          ^
vlfeat/vl/svm.c:2024:33: style: The scope of the variable 'biasRate' can be reduced. [variableScope]
  double inner, gradient, rate, biasRate, p ;
                                ^
vlfeat/vl/svm.c:2024:43: style: The scope of the variable 'p' can be reduced. [variableScope]
  double inner, gradient, rate, biasRate, p ;
                                          ^
vlfeat/vl/svm.c:980:42: style:inconclusive: Function 'vl_svm_new_with_dataset' argument 1 names different: declaration 'type' definition 'solver'. [funcArgNamesDifferent]
vl_svm_new_with_dataset (VlSvmSolverType solver,
                                         ^
vlfeat/vl/svm.h:99:60: note: Function 'vl_svm_new_with_dataset' argument 1 names different: declaration 'type' definition 'solver'.
VL_EXPORT VlSvm * vl_svm_new_with_dataset (VlSvmSolverType type,
                                                           ^
vlfeat/vl/svm.c:980:42: note: Function 'vl_svm_new_with_dataset' argument 1 names different: declaration 'type' definition 'solver'.
vl_svm_new_with_dataset (VlSvmSolverType solver,
                                         ^
vlfeat/vl/svm.c:1014:48: style:inconclusive: Function 'vl_svm_new_with_abstract_data' argument 1 names different: declaration 'type' definition 'solver'. [funcArgNamesDifferent]
vl_svm_new_with_abstract_data (VlSvmSolverType solver,
                                               ^
vlfeat/vl/svm.h:104:66: note: Function 'vl_svm_new_with_abstract_data' argument 1 names different: declaration 'type' definition 'solver'.
VL_EXPORT VlSvm * vl_svm_new_with_abstract_data (VlSvmSolverType type,
                                                                 ^
vlfeat/vl/svm.c:1014:48: note: Function 'vl_svm_new_with_abstract_data' argument 1 names different: declaration 'type' definition 'solver'.
vl_svm_new_with_abstract_data (VlSvmSolverType solver,
                                               ^
vlfeat/vl/svm.c:1223:58: style:inconclusive: Function 'vl_svm_set_max_num_iterations' argument 2 names different: declaration 'maxNumIterations' definition 'n'. [funcArgNamesDifferent]
void vl_svm_set_max_num_iterations (VlSvm *self, vl_size n)
                                                         ^
vlfeat/vl/svm.h:137:68: note: Function 'vl_svm_set_max_num_iterations' argument 2 names different: declaration 'maxNumIterations' definition 'n'.
VL_EXPORT void vl_svm_set_max_num_iterations (VlSvm *self, vl_size maxNumIterations) ;
                                                                   ^
vlfeat/vl/svm.c:1223:58: note: Function 'vl_svm_set_max_num_iterations' argument 2 names different: declaration 'maxNumIterations' definition 'n'.
void vl_svm_set_max_num_iterations (VlSvm *self, vl_size n)
                                                         ^
vlfeat/vl/svm.c:1603:27: warning: Function 'vl_svm_hinge_loss' argument order different: declaration 'label, inner' definition 'inner, label' [funcArgOrderDifferent]
vl_svm_hinge_loss (double inner, double label)
                          ^
vlfeat/vl/svm.h:164:44: note: Function 'vl_svm_hinge_loss' argument order different: declaration 'label, inner' definition 'inner, label'
VL_EXPORT double vl_svm_hinge_loss (double label, double inner) ;
                                           ^
vlfeat/vl/svm.c:1603:27: note: Function 'vl_svm_hinge_loss' argument order different: declaration 'label, inner' definition 'inner, label'
vl_svm_hinge_loss (double inner, double label)
                          ^
vlfeat/vl/svm.c:1611:38: warning: Function 'vl_svm_hinge_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label' [funcArgOrderDifferent]
vl_svm_hinge_loss_derivative (double inner, double label)
                                     ^
vlfeat/vl/svm.h:165:55: note: Function 'vl_svm_hinge_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label'
VL_EXPORT double vl_svm_hinge_loss_derivative (double label, double inner) ;
                                                      ^
vlfeat/vl/svm.c:1611:38: note: Function 'vl_svm_hinge_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label'
vl_svm_hinge_loss_derivative (double inner, double label)
                                     ^
vlfeat/vl/svm.c:1626:37: warning: Function 'vl_svm_hinge_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label' [funcArgOrderDifferent]
vl_svm_hinge_conjugate_loss (double u, double label) {
                                    ^
vlfeat/vl/svm.h:166:54: note: Function 'vl_svm_hinge_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label'
VL_EXPORT double vl_svm_hinge_conjugate_loss (double label, double u) ;
                                                     ^
vlfeat/vl/svm.c:1626:37: note: Function 'vl_svm_hinge_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label'
vl_svm_hinge_conjugate_loss (double u, double label) {
                                    ^
vlfeat/vl/svm.c:1646:28: warning: Function 'vl_svm_hinge2_loss' argument order different: declaration 'label, inner' definition 'inner, label' [funcArgOrderDifferent]
vl_svm_hinge2_loss (double inner,double label)
                           ^
vlfeat/vl/svm.h:170:45: note: Function 'vl_svm_hinge2_loss' argument order different: declaration 'label, inner' definition 'inner, label'
VL_EXPORT double vl_svm_hinge2_loss (double label, double inner) ;
                                            ^
vlfeat/vl/svm.c:1646:28: note: Function 'vl_svm_hinge2_loss' argument order different: declaration 'label, inner' definition 'inner, label'
vl_svm_hinge2_loss (double inner,double label)
                           ^
vlfeat/vl/svm.c:1655:39: warning: Function 'vl_svm_hinge2_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label' [funcArgOrderDifferent]
vl_svm_hinge2_loss_derivative (double inner, double label)
                                      ^
vlfeat/vl/svm.h:171:56: note: Function 'vl_svm_hinge2_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label'
VL_EXPORT double vl_svm_hinge2_loss_derivative (double label, double inner) ;
                                                       ^
vlfeat/vl/svm.c:1655:39: note: Function 'vl_svm_hinge2_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label'
vl_svm_hinge2_loss_derivative (double inner, double label)
                                      ^
vlfeat/vl/svm.c:1667:38: warning: Function 'vl_svm_hinge2_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label' [funcArgOrderDifferent]
vl_svm_hinge2_conjugate_loss (double u, double label) {
                                     ^
vlfeat/vl/svm.h:172:55: note: Function 'vl_svm_hinge2_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label'
VL_EXPORT double vl_svm_hinge2_conjugate_loss (double label, double u) ;
                                                      ^
vlfeat/vl/svm.c:1667:38: note: Function 'vl_svm_hinge2_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label'
vl_svm_hinge2_conjugate_loss (double u, double label) {
                                     ^
vlfeat/vl/svm.c:1686:24: warning: Function 'vl_svm_l1_loss' argument order different: declaration 'label, inner' definition 'inner, label' [funcArgOrderDifferent]
vl_svm_l1_loss (double inner,double label)
                       ^
vlfeat/vl/svm.h:176:41: note: Function 'vl_svm_l1_loss' argument order different: declaration 'label, inner' definition 'inner, label'
VL_EXPORT double vl_svm_l1_loss (double label, double inner) ;
                                        ^
vlfeat/vl/svm.c:1686:24: note: Function 'vl_svm_l1_loss' argument order different: declaration 'label, inner' definition 'inner, label'
vl_svm_l1_loss (double inner,double label)
                       ^
vlfeat/vl/svm.c:1694:35: warning: Function 'vl_svm_l1_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label' [funcArgOrderDifferent]
vl_svm_l1_loss_derivative (double inner, double label)
                                  ^
vlfeat/vl/svm.h:177:52: note: Function 'vl_svm_l1_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label'
VL_EXPORT double vl_svm_l1_loss_derivative (double label, double inner) ;
                                                   ^
vlfeat/vl/svm.c:1694:35: note: Function 'vl_svm_l1_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label'
vl_svm_l1_loss_derivative (double inner, double label)
                                  ^
vlfeat/vl/svm.c:1706:34: warning: Function 'vl_svm_l1_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label' [funcArgOrderDifferent]
vl_svm_l1_conjugate_loss (double u, double label) {
                                 ^
vlfeat/vl/svm.h:178:51: note: Function 'vl_svm_l1_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label'
VL_EXPORT double vl_svm_l1_conjugate_loss (double label, double u) ;
                                                  ^
vlfeat/vl/svm.c:1706:34: note: Function 'vl_svm_l1_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label'
vl_svm_l1_conjugate_loss (double u, double label) {
                                 ^
vlfeat/vl/svm.c:1729:24: warning: Function 'vl_svm_l2_loss' argument order different: declaration 'label, inner' definition 'inner, label' [funcArgOrderDifferent]
vl_svm_l2_loss (double inner,double label)
                       ^
vlfeat/vl/svm.h:182:41: note: Function 'vl_svm_l2_loss' argument order different: declaration 'label, inner' definition 'inner, label'
VL_EXPORT double vl_svm_l2_loss (double label, double inner) ;
                                        ^
vlfeat/vl/svm.c:1729:24: note: Function 'vl_svm_l2_loss' argument order different: declaration 'label, inner' definition 'inner, label'
vl_svm_l2_loss (double inner,double label)
                       ^
vlfeat/vl/svm.c:1738:35: warning: Function 'vl_svm_l2_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label' [funcArgOrderDifferent]
vl_svm_l2_loss_derivative (double inner, double label)
                                  ^
vlfeat/vl/svm.h:183:52: note: Function 'vl_svm_l2_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label'
VL_EXPORT double vl_svm_l2_loss_derivative (double label, double inner) ;
                                                   ^
vlfeat/vl/svm.c:1738:35: note: Function 'vl_svm_l2_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label'
vl_svm_l2_loss_derivative (double inner, double label)
                                  ^
vlfeat/vl/svm.c:1746:34: warning: Function 'vl_svm_l2_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label' [funcArgOrderDifferent]
vl_svm_l2_conjugate_loss (double u, double label) {
                                 ^
vlfeat/vl/svm.h:184:51: note: Function 'vl_svm_l2_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label'
VL_EXPORT double vl_svm_l2_conjugate_loss (double label, double u) ;
                                                  ^
vlfeat/vl/svm.c:1746:34: note: Function 'vl_svm_l2_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label'
vl_svm_l2_conjugate_loss (double u, double label) {
                                 ^
vlfeat/vl/svm.c:1760:30: warning: Function 'vl_svm_logistic_loss' argument order different: declaration 'label, inner' definition 'inner, label' [funcArgOrderDifferent]
vl_svm_logistic_loss (double inner,double label)
                             ^
vlfeat/vl/svm.h:188:47: note: Function 'vl_svm_logistic_loss' argument order different: declaration 'label, inner' definition 'inner, label'
VL_EXPORT double vl_svm_logistic_loss (double label, double inner) ;
                                              ^
vlfeat/vl/svm.c:1760:30: note: Function 'vl_svm_logistic_loss' argument order different: declaration 'label, inner' definition 'inner, label'
vl_svm_logistic_loss (double inner,double label)
                             ^
vlfeat/vl/svm.c:1773:41: warning: Function 'vl_svm_logistic_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label' [funcArgOrderDifferent]
vl_svm_logistic_loss_derivative (double inner, double label)
                                        ^
vlfeat/vl/svm.h:189:58: note: Function 'vl_svm_logistic_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label'
VL_EXPORT double vl_svm_logistic_loss_derivative (double label, double inner) ;
                                                         ^
vlfeat/vl/svm.c:1773:41: note: Function 'vl_svm_logistic_loss_derivative' argument order different: declaration 'label, inner' definition 'inner, label'
vl_svm_logistic_loss_derivative (double inner, double label)
                                        ^
vlfeat/vl/svm.c:1789:40: warning: Function 'vl_svm_logistic_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label' [funcArgOrderDifferent]
vl_svm_logistic_conjugate_loss (double u, double label) {
                                       ^
vlfeat/vl/svm.h:190:57: note: Function 'vl_svm_logistic_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label'
VL_EXPORT double vl_svm_logistic_conjugate_loss (double label, double u) ;
                                                        ^
vlfeat/vl/svm.c:1789:40: note: Function 'vl_svm_logistic_conjugate_loss' argument order different: declaration 'label, u' definition 'u, label'
vl_svm_logistic_conjugate_loss (double u, double label) {
                                       ^
vlfeat/vl/svmdataset.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
vlfeat/vl/svmdataset.c:164:42: style:inconclusive: Function 'vl_svmdataset_delete' argument 1 names different: declaration 'dataset' definition 'self'. [funcArgNamesDifferent]
void vl_svmdataset_delete (VlSvmDataset *self)
                                         ^
vlfeat/vl/svmdataset.h:56:53: note: Function 'vl_svmdataset_delete' argument 1 names different: declaration 'dataset' definition 'self'.
VL_EXPORT void vl_svmdataset_delete (VlSvmDataset * dataset) ;
                                                    ^
vlfeat/vl/svmdataset.c:164:42: note: Function 'vl_svmdataset_delete' argument 1 names different: declaration 'dataset' definition 'self'.
void vl_svmdataset_delete (VlSvmDataset *self)
                                         ^
vlfeat/vl/vlad.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
matlab/src/bits/impl/imread_gdiplus.cpp:61:1: error: The one definition rule is violated, different classes/structs have the same name 'Impl' [ctuOneDefinitionRuleViolation]
class vl::ImageReader::Impl
^
matlab/src/bits/impl/imread_libjpeg.cpp:32:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class vl::ImageReader::Impl
^
matlab/src/bits/impl/imread_gdiplus.cpp:61:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class vl::ImageReader::Impl
^
matlab/src/bits/impl/imread_gdiplus.cpp:61:1: error: The one definition rule is violated, different classes/structs have the same name 'Impl' [ctuOneDefinitionRuleViolation]
class vl::ImageReader::Impl
^
matlab/src/bits/impl/imread_quartz.cpp:30:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
struct vl::ImageReader::Impl
^
matlab/src/bits/impl/imread_gdiplus.cpp:61:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class vl::ImageReader::Impl
^
vlfeat/vl/generic.c:1524:0: style: The function 'DllMain' is never used. [unusedFunction]

^
vlfeat/vl/mathop_sse2.c:265:0: style: The function '_vl_distance_chi2_sse2_SFX' is never used. [unusedFunction]

^
vlfeat/vl/mathop_sse2.c:222:0: style: The function '_vl_distance_l1_sse2_SFX' is never used. [unusedFunction]

^
vlfeat/vl/mathop_avx.c:69:0: style: The function '_vl_distance_l2_avx_SFX' is never used. [unusedFunction]

^
vlfeat/vl/mathop_sse2.c:118:0: style: The function '_vl_distance_l2_sse2_SFX' is never used. [unusedFunction]

^
vlfeat/vl/mathop_avx.c:114:0: style: The function '_vl_distance_mahalanobis_sq_avx_SFX' is never used. [unusedFunction]

^
vlfeat/vl/mathop_sse2.c:162:0: style: The function '_vl_distance_mahalanobis_sq_sse2_SFX' is never used. [unusedFunction]

^
vlfeat/vl/mathop_sse2.c:77:0: style: The function '_vl_dot_sse2_SFX' is never used. [unusedFunction]

^
vlfeat/vl/mathop_sse2.c:77:0: style: The function '_vl_dot_sse2_d' is never used. [unusedFunction]

^
vlfeat/vl/mathop_sse2.c:77:0: style: The function '_vl_dot_sse2_f' is never used. [unusedFunction]

^
vlfeat/vl/fisher.c:364:0: style: The function '_vl_fisher_encode_SFX' is never used. [unusedFunction]

^
vlfeat/vl/mathop_sse2.c:410:0: style: The function '_vl_kernel_chi2_sse2_SFX' is never used. [unusedFunction]

^
vlfeat/vl/mathop_sse2.c:358:0: style: The function '_vl_kernel_l1_sse2_SFX' is never used. [unusedFunction]

^
vlfeat/vl/mathop_sse2.c:320:0: style: The function '_vl_kernel_l2_sse2_SFX' is never used. [unusedFunction]

^
vlfeat/vl/kmeans.c:589:0: style: The function '_vl_kmeans_init_centers_plus_plus_SFX' is never used. [unusedFunction]

^
vlfeat/vl/kmeans.c:528:0: style: The function '_vl_kmeans_init_centers_with_rand_data_SFX' is never used. [unusedFunction]

^
vlfeat/vl/kmeans.c:1751:0: style: The function '_vl_kmeans_refine_centers_SFX' is never used. [unusedFunction]

^
vlfeat/vl/kmeans.c:510:0: style: The function '_vl_kmeans_set_centers_SFX' is never used. [unusedFunction]

^
vlfeat/vl/vlad.c:164:0: style: The function '_vl_vlad_encode_SFX' is never used. [unusedFunction]

^
vlfeat/vl/mathop_avx.c:172:0: style: The function '_vl_weighted_mean_avx_SFX' is never used. [unusedFunction]

^
vlfeat/vl/mathop_avx.c:172:0: style: The function '_vl_weighted_mean_avx_d' is never used. [unusedFunction]

^
vlfeat/vl/mathop_avx.c:172:0: style: The function '_vl_weighted_mean_avx_f' is never used. [unusedFunction]

^
vlfeat/vl/mathop_sse2.c:517:0: style: The function '_vl_weighted_mean_sse2_SFX' is never used. [unusedFunction]

^
vlfeat/vl/mathop_avx.c:217:0: style: The function '_vl_weighted_sigma_avx_SFX' is never used. [unusedFunction]

^
vlfeat/vl/mathop_avx.c:217:0: style: The function '_vl_weighted_sigma_avx_d' is never used. [unusedFunction]

^
vlfeat/vl/mathop_avx.c:217:0: style: The function '_vl_weighted_sigma_avx_f' is never used. [unusedFunction]

^
vlfeat/vl/mathop_sse2.c:460:0: style: The function '_vl_weighted_sigma_sse2_SFX' is never used. [unusedFunction]

^
matlab/src/bits/impl/tinythread.cpp:246:0: style: The function 'detach' is never used. [unusedFunction]

^
matlab/src/bits/impl/tinythread.cpp:261:0: style: The function 'get_id' is never used. [unusedFunction]

^
vlfeat/src/test_heap-def.c:48:0: style: The function 'h_cmp' is never used. [unusedFunction]

^
vlfeat/src/test_heap-def.c:51:0: style: The function 'h_swap' is never used. [unusedFunction]

^
matlab/src/bits/impl/tinythread.cpp:272:0: style: The function 'hardware_concurrency' is never used. [unusedFunction]

^
vlfeat/toolbox/aib/vl_aib.c:192:0: style: The function 'mexFunction' is never used. [unusedFunction]

^
matlab/src/bits/impl/tinythread.cpp:95:0: style: The function 'notify_one' is never used. [unusedFunction]

^
vlfeat/src/test_heap-def.c:21:0: style: The function 's_cmp' is never used. [unusedFunction]

^
vlfeat/src/test_heap-def.c:25:0: style: The function 's_swap' is never used. [unusedFunction]

^
vlfeat/src/test_gmm.c:223:0: style: The function 'saveResults' is never used. [unusedFunction]

^
vlfeat/vl/array.c:202:0: style: The function 'vl_array_delete' is never used. [unusedFunction]

^
vlfeat/vl/array.c:97:0: style: The function 'vl_array_init_matrix' is never used. [unusedFunction]

^
vlfeat/vl/array.c:112:0: style: The function 'vl_array_init_matrix_envelope' is never used. [unusedFunction]

^
vlfeat/vl/array.c:162:0: style: The function 'vl_array_new_matrix' is never used. [unusedFunction]

^
vlfeat/vl/array.c:191:0: style: The function 'vl_array_new_matrix_envelope' is never used. [unusedFunction]

^
vlfeat/vl/generic.c:1106:0: style: The function 'vl_cpu_has_sse3' is never used. [unusedFunction]

^
vlfeat/vl/dsift.c:467:0: style: The function 'vl_dsift_new_basic' is never used. [unusedFunction]

^
vlfeat/vl/stringop.c:409:0: style: The function 'vl_enumeration_get' is never used. [unusedFunction]

^
vlfeat/vl/stringop.c:431:0: style: The function 'vl_enumeration_get_casei' is never used. [unusedFunction]

^
vlfeat/vl/generic.c:1143:0: style: The function 'vl_get_thread_limit' is never used. [unusedFunction]

^
vlfeat/vl/gmm.c:622:0: style: The function 'vl_gmm_get_kmeans_init_object' is never used. [unusedFunction]

^
vlfeat/vl/gmm.c:469:0: style: The function 'vl_gmm_get_loglikelihood' is never used. [unusedFunction]

^
vlfeat/vl/gmm.c:458:0: style: The function 'vl_gmm_get_num_data' is never used. [unusedFunction]

^
vlfeat/vl/gmm.c:480:0: style: The function 'vl_gmm_get_verbosity' is never used. [unusedFunction]

^
vlfeat/vl/gmm.c:1481:0: style: The function 'vl_gmm_new_copy' is never used. [unusedFunction]

^
vlfeat/vl/hikmeans.c:335:0: style: The function 'vl_hikm_get_max_niters' is never used. [unusedFunction]

^
vlfeat/vl/hikmeans.c:346:0: style: The function 'vl_hikm_get_root' is never used. [unusedFunction]

^
vlfeat/vl/hikmeans.c:324:0: style: The function 'vl_hikm_get_verbosity' is never used. [unusedFunction]

^
vlfeat/vl/hikmeans.c:368:0: style: The function 'vl_hikm_set_max_niters' is never used. [unusedFunction]

^
vlfeat/vl/homkermap.c:476:0: style: The function 'vl_homogeneouskernelmap_get_kernel_type' is never used. [unusedFunction]

^
vlfeat/vl/homkermap.c:452:0: style: The function 'vl_homogeneouskernelmap_get_order' is never used. [unusedFunction]

^
vlfeat/vl/homkermap.c:488:0: style: The function 'vl_homogeneouskernelmap_get_window_type' is never used. [unusedFunction]

^
vlfeat/vl/ikmeans.c:257:0: style: The function 'vl_ikm_get_max_niters' is never used. [unusedFunction]

^
vlfeat/vl/ikmeans.c:246:0: style: The function 'vl_ikm_get_verbosity' is never used. [unusedFunction]

^
vlfeat/vl/imopv.c:511:0: style: The function 'vl_imconvcoltri_d' is never used. [unusedFunction]

^
vlfeat/vl/imopv.c:723:0: style: The function 'vl_imgradient_d' is never used. [unusedFunction]

^
vlfeat/vl/imopv.c:723:0: style: The function 'vl_imgradient_f' is never used. [unusedFunction]

^
vlfeat/vl/imopv.c:875:0: style: The function 'vl_imgradient_polar_d' is never used. [unusedFunction]

^
vlfeat/vl/imopv.c:1042:0: style: The function 'vl_imintegral_SFX' is never used. [unusedFunction]

^
vlfeat/vl/imopv.c:645:0: style: The function 'vl_imsmooth_d' is never used. [unusedFunction]

^
vlfeat/vl/kdtree.c:744:0: style: The function 'vl_kdforest_query' is never used. [unusedFunction]

^
vlfeat/vl/kdtree.c:1079:0: style: The function 'vl_kdforestsearcher_get_forest' is never used. [unusedFunction]

^
vlfeat/vl/kmeans.c:434:0: style: The function 'vl_kmeans_new_copy' is never used. [unusedFunction]

^
vlfeat/vl/kmeans.c:1947:0: style: The function 'vl_kmeans_quantize_ann' is never used. [unusedFunction]

^
vlfeat/vl/kmeans.c:1806:0: style: The function 'vl_kmeans_set_centers' is never used. [unusedFunction]

^
vlfeat/vl/liop.c:405:0: style: The function 'vl_liopdesc_new_basic' is never used. [unusedFunction]

^
vlfeat/vl/generic.c:1330:0: style: The function 'vl_realloc' is never used. [unusedFunction]

^
vlfeat/vl/scalespace.c:641:0: style: The function 'vl_scalespace_delete' is never used. [unusedFunction]

^
vlfeat/vl/scalespace.c:536:0: style: The function 'vl_scalespace_new' is never used. [unusedFunction]

^
vlfeat/vl/scalespace.c:604:0: style: The function 'vl_scalespace_new_copy' is never used. [unusedFunction]

^
vlfeat/vl/scalespace.c:812:0: style: The function 'vl_scalespace_put_image' is never used. [unusedFunction]

^
vlfeat/vl/scalespace.c:337:0: style: The function 'vl_scalespacegeometry_is_equal' is never used. [unusedFunction]

^
vlfeat/vl/generic.c:1289:0: style: The function 'vl_set_alloc_func' is never used. [unusedFunction]

^
vlfeat/vl/generic.c:1372:0: style: The function 'vl_set_printf_func' is never used. [unusedFunction]

^
vlfeat/vl/mathop.c:839:0: style: The function 'vl_solve_linear_system_3' is never used. [unusedFunction]

^
vlfeat/vl/stringop.c:345:0: style: The function 'vl_string_find_char_rev' is never used. [unusedFunction]

^
vlfeat/vl/svm.c:1212:0: style: The function 'vl_svm_get_iteration_number' is never used. [unusedFunction]

^
vlfeat/vl/svm.c:1331:0: style: The function 'vl_svm_get_weights' is never used. [unusedFunction]

^
vlfeat/vl/svm.c:957:0: style: The function 'vl_svm_new' is never used. [unusedFunction]

^
vlfeat/vl/svm.c:1288:0: style: The function 'vl_svm_set_lambda' is never used. [unusedFunction]

^
vlfeat/vl/svmdataset.c:179:0: style: The function 'vl_svmdataset_get_data' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

